var tipuesearch = {"pages":[{"title":" Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form. ","text":"Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form. 軸対称Skyrme Hartree-Fock法を用いて軽原子核の基底状態の分析を行うためのFortranプログラムです。 How to Read This Documentation The listings below are not exhaustive.\nTo see the full listings use the links at the top of the page.\nAlso, if you know what you're looking for, there is a search bar in the top right.","tags":"home","loc":"index.html"},{"title":"calc_Woods_Saxon – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_Woods_Saxon() Uses global_variables iso_fortran_env constants_and_parameters proc~~calc_woods_saxon~~UsesGraph proc~calc_woods_saxon determine_meanfield_potential::calc_Woods_Saxon iso_fortran_env iso_fortran_env proc~calc_woods_saxon->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_woods_saxon->module~constants_and_parameters module~global_variables global_variables proc~calc_woods_saxon->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Contents None","tags":"","loc":"proc/calc_woods_saxon.html"},{"title":"calc_coulomb_pot – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_coulomb_pot() Uses global_variables iso_fortran_env poisson_problem proc~~calc_coulomb_pot~~UsesGraph proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot iso_fortran_env iso_fortran_env proc~calc_coulomb_pot->iso_fortran_env module~global_variables global_variables proc~calc_coulomb_pot->module~global_variables module~poisson_problem poisson_problem proc~calc_coulomb_pot->module~poisson_problem module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_coulomb_pot~~CallsGraph proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack->proc~get_k proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack->proc~use_dgesv dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_coulomb_pot~~CalledByGraph proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->proc~calc_coulomb_pot proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_pot_u->proc~calc_pot_u_np proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_u proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_coulomb_pot.html"},{"title":"calc_pot_B – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_pot_B() Uses global_variables constants_and_parameters proc~~calc_pot_b~~UsesGraph proc~calc_pot_b determine_meanfield_potential::calc_pot_B module~constants_and_parameters constants_and_parameters proc~calc_pot_b->module~constants_and_parameters module~global_variables global_variables proc~calc_pot_b->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~calc_pot_b~~CalledByGraph proc~calc_pot_b determine_meanfield_potential::calc_pot_B proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_b proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_pot_b.html"},{"title":"calc_pot_U – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_pot_U() Arguments None Calls proc~~calc_pot_u~~CallsGraph proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u->proc~calc_pot_u_np b0pt b0pt proc~calc_pot_u_np->b0pt b0t b0t proc~calc_pot_u_np->b0t b1pt b1pt proc~calc_pot_u_np->b1pt b1t b1t proc~calc_pot_u_np->b1t b2pt b2pt proc~calc_pot_u_np->b2pt b2t b2t proc~calc_pot_u_np->b2t b3pt b3pt proc~calc_pot_u_np->b3pt b3pt2 b3pt2 proc~calc_pot_u_np->b3pt2 b3t b3t proc~calc_pot_u_np->b3t b4pt b4pt proc~calc_pot_u_np->b4pt b4t b4t proc~calc_pot_u_np->b4t proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_pot_u_np->proc~calc_coulomb_pot proc~write_u_term write_to_file::write_U_term proc~calc_pot_u_np->proc~write_u_term proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack->proc~get_k proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack->proc~use_dgesv dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_pot_u~~CalledByGraph proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_u proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_pot_u.html"},{"title":"calc_pot_U_np – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_pot_U_np(np_str, is_coulomb) Uses write_to_file global_variables iso_fortran_env constants_and_parameters proc~~calc_pot_u_np~~UsesGraph proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np iso_fortran_env iso_fortran_env proc~calc_pot_u_np->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_pot_u_np->module~constants_and_parameters module~global_variables global_variables proc~calc_pot_u_np->module~global_variables module~write_to_file write_to_file proc~calc_pot_u_np->module~write_to_file module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~write_to_file->iso_fortran_env module~write_to_file->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: np_str logical, intent(in), optional :: is_coulomb Calls proc~~calc_pot_u_np~~CallsGraph proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np b0pt b0pt proc~calc_pot_u_np->b0pt b0t b0t proc~calc_pot_u_np->b0t b1pt b1pt proc~calc_pot_u_np->b1pt b1t b1t proc~calc_pot_u_np->b1t b2pt b2pt proc~calc_pot_u_np->b2pt b2t b2t proc~calc_pot_u_np->b2t b3pt b3pt proc~calc_pot_u_np->b3pt b3pt2 b3pt2 proc~calc_pot_u_np->b3pt2 b3t b3t proc~calc_pot_u_np->b3t b4pt b4pt proc~calc_pot_u_np->b4pt b4t b4t proc~calc_pot_u_np->b4t proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_pot_u_np->proc~calc_coulomb_pot proc~write_u_term write_to_file::write_U_term proc~calc_pot_u_np->proc~write_u_term proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack->proc~get_k proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack->proc~use_dgesv dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_pot_u_np~~CalledByGraph proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_pot_u->proc~calc_pot_u_np proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_u proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/calc_pot_u_np.html"},{"title":"calc_pot_W – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_pot_W() Uses math_derivation global_variables iso_fortran_env constants_and_parameters proc~~calc_pot_w~~UsesGraph proc~calc_pot_w determine_meanfield_potential::calc_pot_W iso_fortran_env iso_fortran_env proc~calc_pot_w->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_pot_w->module~constants_and_parameters module~global_variables global_variables proc~calc_pot_w->module~global_variables module~math_derivation math_derivation proc~calc_pot_w->module~math_derivation module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_derivation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~calc_pot_w~~CalledByGraph proc~calc_pot_w determine_meanfield_potential::calc_pot_W proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_w proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_pot_w.html"},{"title":"math_diff_2r_9point_realfunc – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function math_diff_2r_9point_realfunc(f) result(f_2r) Uses constants_and_parameters proc~~math_diff_2r_9point_realfunc~~UsesGraph proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc module~constants_and_parameters constants_and_parameters proc~math_diff_2r_9point_realfunc->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) Called by proc~~math_diff_2r_9point_realfunc~~CalledByGraph proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point math_derivation::math_diff_2r_9point interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_2r_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_2r_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_2r_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/math_diff_2r_9point_realfunc.html"},{"title":"math_diff_2z_9point_realfunc – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function math_diff_2z_9point_realfunc(f) result(f_2z) Uses constants_and_parameters proc~~math_diff_2z_9point_realfunc~~UsesGraph proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc module~constants_and_parameters constants_and_parameters proc~math_diff_2z_9point_realfunc->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) Called by proc~~math_diff_2z_9point_realfunc~~CalledByGraph proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point math_derivation::math_diff_2z_9point interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_2z_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_2z_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_2z_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/math_diff_2z_9point_realfunc.html"},{"title":"math_diff_r_9point_complexfunc – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function math_diff_r_9point_complexfunc(f) result(f_r) Uses constants_and_parameters proc~~math_diff_r_9point_complexfunc~~UsesGraph proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc module~constants_and_parameters constants_and_parameters proc~math_diff_r_9point_complexfunc->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:) Called by proc~~math_diff_r_9point_complexfunc~~CalledByGraph proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point math_derivation::math_diff_r_9point interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->interface~math_diff_r_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_r_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_r_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_r_9point proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->interface~math_diff_r_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_densities->proc~calc_spin_orbit_density_and_div proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi->proc~calc_bpsi program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/math_diff_r_9point_complexfunc.html"},{"title":"math_diff_r_9point_realfunc – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function math_diff_r_9point_realfunc(f) result(f_r) Uses constants_and_parameters proc~~math_diff_r_9point_realfunc~~UsesGraph proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc module~constants_and_parameters constants_and_parameters proc~math_diff_r_9point_realfunc->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) Called by proc~~math_diff_r_9point_realfunc~~CalledByGraph proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point math_derivation::math_diff_r_9point interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->interface~math_diff_r_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_r_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_r_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_r_9point proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->interface~math_diff_r_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_densities->proc~calc_spin_orbit_density_and_div proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi->proc~calc_bpsi program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/math_diff_r_9point_realfunc.html"},{"title":"math_diff_z_9point_complexfunc – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function math_diff_z_9point_complexfunc(f) result(f_z) Uses constants_and_parameters proc~~math_diff_z_9point_complexfunc~~UsesGraph proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc module~constants_and_parameters constants_and_parameters proc~math_diff_z_9point_complexfunc->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:) Called by proc~~math_diff_z_9point_complexfunc~~CalledByGraph proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point math_derivation::math_diff_z_9point interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->interface~math_diff_z_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_z_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_z_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_z_9point proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->interface~math_diff_z_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_densities->proc~calc_spin_orbit_density_and_div proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi->proc~calc_bpsi program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/math_diff_z_9point_complexfunc.html"},{"title":"math_diff_z_9point_realfunc – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function math_diff_z_9point_realfunc(f) result(f_z) Uses constants_and_parameters proc~~math_diff_z_9point_realfunc~~UsesGraph proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc module~constants_and_parameters constants_and_parameters proc~math_diff_z_9point_realfunc->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) Called by proc~~math_diff_z_9point_realfunc~~CalledByGraph proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point math_derivation::math_diff_z_9point interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->interface~math_diff_z_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_z_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_z_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_z_9point proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->interface~math_diff_z_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_densities->proc~calc_spin_orbit_density_and_div proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi->proc~calc_bpsi program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/math_diff_z_9point_realfunc.html"},{"title":"math_diff_2r_9point – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public interface math_diff_2r_9point Calls interface~~math_diff_2r_9point~~CallsGraph interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~math_diff_2r_9point~~CalledByGraph interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_2r_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_2r_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_2r_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures math_diff_2r_9point_realfunc Module Procedures public  function math_diff_2r_9point_realfunc (f) result(f_2r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:)","tags":"","loc":"interface/math_diff_2r_9point.html"},{"title":"math_diff_2z_9point – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public interface math_diff_2z_9point Calls interface~~math_diff_2z_9point~~CallsGraph interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~math_diff_2z_9point~~CalledByGraph interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_2z_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_2z_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_2z_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures math_diff_2z_9point_realfunc Module Procedures public  function math_diff_2z_9point_realfunc (f) result(f_2z) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:)","tags":"","loc":"interface/math_diff_2z_9point.html"},{"title":"math_diff_r_9point – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public interface math_diff_r_9point Calls interface~~math_diff_r_9point~~CallsGraph interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~math_diff_r_9point~~CalledByGraph interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->interface~math_diff_r_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_r_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_r_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_r_9point proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->interface~math_diff_r_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_densities->proc~calc_spin_orbit_density_and_div proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi->proc~calc_bpsi program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures math_diff_r_9point_realfunc math_diff_r_9point_complexfunc Module Procedures public  function math_diff_r_9point_realfunc (f) result(f_r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public  function math_diff_r_9point_complexfunc (f) result(f_r) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:)","tags":"","loc":"interface/math_diff_r_9point.html"},{"title":"math_diff_z_9point – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public interface math_diff_z_9point Calls interface~~math_diff_z_9point~~CallsGraph interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~math_diff_z_9point~~CalledByGraph interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->interface~math_diff_z_9point proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->interface~math_diff_z_9point proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->interface~math_diff_z_9point proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->interface~math_diff_z_9point proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->interface~math_diff_z_9point proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_densities->proc~calc_spin_orbit_density_and_div proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_densities proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi->proc~calc_bpsi program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures math_diff_z_9point_realfunc math_diff_z_9point_complexfunc Module Procedures public  function math_diff_z_9point_realfunc (f) result(f_z) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public  function math_diff_z_9point_complexfunc (f) result(f_z) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:)","tags":"","loc":"interface/math_diff_z_9point.html"},{"title":"Hermite_n – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function Hermite_n(n, x) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: x Return Value real(kind=real64) Called by proc~~hermite_n~~CalledByGraph proc~hermite_n spacial_function::Hermite_n proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~set_harmonic_occ->proc~hermite_n proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->proc~set_harmonic_occ proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->proc~set_harmonic_occ proc~initial_settings main::initial_settings proc~initial_settings->proc~prep_initial_wavefunction proc~initial_settings->proc~prep_time_reversal_wavefunction program~main main program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hermite_n.html"},{"title":"Laguerre_nl – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function Laguerre_nl(n, l, x) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: l real(kind=real64), intent(in) :: x Return Value real(kind=real64) Called by proc~~laguerre_nl~~CalledByGraph proc~laguerre_nl spacial_function::Laguerre_nl proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~set_harmonic_occ->proc~laguerre_nl proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->proc~set_harmonic_occ proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->proc~set_harmonic_occ proc~initial_settings main::initial_settings proc~initial_settings->proc~prep_initial_wavefunction proc~initial_settings->proc~prep_time_reversal_wavefunction program~main main program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/laguerre_nl.html"},{"title":"sympson_volume_integrate – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function sympson_volume_integrate(f) result(result) Uses global_variables constants_and_parameters proc~~sympson_volume_integrate~~UsesGraph proc~sympson_volume_integrate math_integrate::sympson_volume_integrate module~constants_and_parameters constants_and_parameters proc~sympson_volume_integrate->module~constants_and_parameters module~global_variables global_variables proc~sympson_volume_integrate->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64) Contents","tags":"","loc":"proc/sympson_volume_integrate.html"},{"title":"volume_integrate – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function volume_integrate(f) result(result) Uses global_variables constants_and_parameters proc~~volume_integrate~~UsesGraph proc~volume_integrate math_integrate::volume_integrate module~constants_and_parameters constants_and_parameters proc~volume_integrate->module~constants_and_parameters module~global_variables global_variables proc~volume_integrate->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64) Called by proc~~volume_integrate~~CalledByGraph proc~volume_integrate math_integrate::volume_integrate proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_coulomb_energy->proc~volume_integrate proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->proc~volume_integrate proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_kinetic_energy_by_integrate->proc~volume_integrate proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_one_particle_energy->proc~volume_integrate proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_pc2_exv->proc~volume_integrate proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_skyrme_energy_by_integrate->proc~volume_integrate proc~overlap_to_file write_to_file::overlap_to_file proc~overlap_to_file->proc~volume_integrate proc~prep_wf_overlap main::prep_wf_overlap proc~prep_wf_overlap->proc~volume_integrate proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_cm_energy->proc~calc_pc2_exv proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_one_particle_energy proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~calc_hf_by_imaginary_time_evolution->proc~schmidt_orthogonalization proc~calc_observables main::calc_observables proc~calc_observables->proc~calc_coulomb_energy proc~calc_observables->proc~calc_kinetic_energy_by_integrate proc~calc_observables->proc~calc_skyrme_energy_by_integrate proc~calc_observables->proc~calc_cm_energy proc~schmidt_orthogonalization->proc~prep_wf_overlap proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_densities proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/volume_integrate.html"},{"title":"overlap_to_file – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function overlap_to_file(idx_1, idx_2) result(ovlp) Uses global_variables math_integrate proc~~overlap_to_file~~UsesGraph proc~overlap_to_file write_to_file::overlap_to_file module~global_variables global_variables proc~overlap_to_file->module~global_variables module~math_integrate math_integrate proc~overlap_to_file->module~math_integrate iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~math_integrate->iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: idx_1 integer(kind=int32), intent(in) :: idx_2 Return Value real(kind=real64) Calls proc~~overlap_to_file~~CallsGraph proc~overlap_to_file write_to_file::overlap_to_file proc~volume_integrate math_integrate::volume_integrate proc~overlap_to_file->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/overlap_to_file.html"},{"title":"make_one_file – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine make_one_file(filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Called by proc~~make_one_file~~CalledByGraph proc~make_one_file write_to_file::make_one_file proc~outputsettings write_to_file::outputsettings proc~outputsettings->proc~make_one_file program~main main program~main->proc~outputsettings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/make_one_file.html"},{"title":"outputsettings – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine outputsettings() Uses constants_and_parameters proc~~outputsettings~~UsesGraph proc~outputsettings write_to_file::outputsettings module~constants_and_parameters constants_and_parameters proc~outputsettings->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~outputsettings~~CallsGraph proc~outputsettings write_to_file::outputsettings proc~make_one_file write_to_file::make_one_file proc~outputsettings->proc~make_one_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~outputsettings~~CalledByGraph proc~outputsettings write_to_file::outputsettings program~main main program~main->proc~outputsettings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/outputsettings.html"},{"title":"write_U_term – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_U_term(b0, b0p, b1, b1p, b2, b2p, b3, b3p, b3p2, b4, b4p, dir, ex, np_str) Uses global_variables constants_and_parameters proc~~write_u_term~~UsesGraph proc~write_u_term write_to_file::write_U_term module~constants_and_parameters constants_and_parameters proc~write_u_term->module~constants_and_parameters module~global_variables global_variables proc~write_u_term->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: b0 (:,:) real(kind=real64), intent(in) :: b0p (:,:) real(kind=real64), intent(in) :: b1 (:,:) real(kind=real64), intent(in) :: b1p (:,:) real(kind=real64), intent(in) :: b2 (:,:) real(kind=real64), intent(in) :: b2p (:,:) real(kind=real64), intent(in) :: b3 (:,:) real(kind=real64), intent(in) :: b3p (:,:) real(kind=real64), intent(in) :: b3p2 (:,:) real(kind=real64), intent(in) :: b4 (:,:) real(kind=real64), intent(in) :: b4p (:,:) real(kind=real64), intent(in) :: dir (:,:) real(kind=real64), intent(in) :: ex (:,:) character(len=1), intent(in) :: np_str Called by proc~~write_u_term~~CalledByGraph proc~write_u_term write_to_file::write_U_term proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->proc~write_u_term proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_pot_u->proc~calc_pot_u_np proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_u proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_u_term.html"},{"title":"write_d_wavefunction – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_d_wavefunction(num) Uses global_variables constants_and_parameters proc~~write_d_wavefunction~~UsesGraph proc~write_d_wavefunction write_to_file::write_d_wavefunction module~constants_and_parameters constants_and_parameters proc~write_d_wavefunction->module~constants_and_parameters module~global_variables global_variables proc~write_d_wavefunction->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num Called by proc~~write_d_wavefunction~~CalledByGraph proc~write_d_wavefunction write_to_file::write_d_wavefunction proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~write_d_wavefunction program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_d_wavefunction.html"},{"title":"write_density_and_derivative – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_density_and_derivative(num) Uses global_variables constants_and_parameters proc~~write_density_and_derivative~~UsesGraph proc~write_density_and_derivative write_to_file::write_density_and_derivative module~constants_and_parameters constants_and_parameters proc~write_density_and_derivative->module~constants_and_parameters module~global_variables global_variables proc~write_density_and_derivative->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num Called by proc~~write_density_and_derivative~~CalledByGraph proc~write_density_and_derivative write_to_file::write_density_and_derivative proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~write_density_and_derivative program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_density_and_derivative.html"},{"title":"write_iter_Energy – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_iter_Energy(iter) Uses global_variables proc~~write_iter_energy~~UsesGraph proc~write_iter_energy write_to_file::write_iter_Energy module~global_variables global_variables proc~write_iter_energy->module~global_variables iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter Called by proc~~write_iter_energy~~CalledByGraph proc~write_iter_energy write_to_file::write_iter_Energy proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~write_iter_energy program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_iter_energy.html"},{"title":"write_meanfield_Energy – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_meanfield_Energy(iter) Uses global_variables proc~~write_meanfield_energy~~UsesGraph proc~write_meanfield_energy write_to_file::write_meanfield_Energy module~global_variables global_variables proc~write_meanfield_energy->module~global_variables iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter Called by proc~~write_meanfield_energy~~CalledByGraph proc~write_meanfield_energy write_to_file::write_meanfield_Energy proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~write_meanfield_energy program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_meanfield_energy.html"},{"title":"write_pot – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_pot(num) Uses global_variables constants_and_parameters proc~~write_pot~~UsesGraph proc~write_pot write_to_file::write_pot module~constants_and_parameters constants_and_parameters proc~write_pot->module~constants_and_parameters module~global_variables global_variables proc~write_pot->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num Called by proc~~write_pot~~CalledByGraph proc~write_pot write_to_file::write_pot proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~write_pot program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_pot.html"},{"title":"write_prep_sort – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_prep_sort(iter) Uses global_variables constants_and_parameters proc~~write_prep_sort~~UsesGraph proc~write_prep_sort write_to_file::write_prep_sort module~constants_and_parameters constants_and_parameters proc~write_prep_sort->module~constants_and_parameters module~global_variables global_variables proc~write_prep_sort->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter Called by proc~~write_prep_sort~~CalledByGraph proc~write_prep_sort write_to_file::write_prep_sort proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~write_prep_sort program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_prep_sort.html"},{"title":"write_wavefunction – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_wavefunction(num) Uses global_variables constants_and_parameters proc~~write_wavefunction~~UsesGraph proc~write_wavefunction write_to_file::write_wavefunction module~constants_and_parameters constants_and_parameters proc~write_wavefunction->module~constants_and_parameters module~global_variables global_variables proc~write_wavefunction->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num Called by proc~~write_wavefunction~~CalledByGraph proc~write_wavefunction write_to_file::write_wavefunction proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~write_wavefunction program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/write_wavefunction.html"},{"title":"calc_PC2_ExV – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function calc_PC2_ExV(nuc_idx) result(expected_value) Uses math_integrate global_variables iso_fortran_env constants_and_parameters proc~~calc_pc2_exv~~UsesGraph proc~calc_pc2_exv determine_observables::calc_PC2_ExV iso_fortran_env iso_fortran_env proc~calc_pc2_exv->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_pc2_exv->module~constants_and_parameters module~global_variables global_variables proc~calc_pc2_exv->module~global_variables module~math_integrate math_integrate proc~calc_pc2_exv->module~math_integrate module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nuc_idx Return Value real(kind=real64) Calls proc~~calc_pc2_exv~~CallsGraph proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~volume_integrate math_integrate::volume_integrate proc~calc_pc2_exv->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_pc2_exv~~CalledByGraph proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_cm_energy->proc~calc_pc2_exv proc~calc_observables main::calc_observables proc~calc_observables->proc~calc_cm_energy proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/calc_pc2_exv.html"},{"title":"calc_CM_Energy – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_CM_Energy() Uses global_variables iso_fortran_env constants_and_parameters proc~~calc_cm_energy~~UsesGraph proc~calc_cm_energy determine_observables::calc_CM_Energy iso_fortran_env iso_fortran_env proc~calc_cm_energy->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_cm_energy->module~constants_and_parameters module~global_variables global_variables proc~calc_cm_energy->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_cm_energy~~CallsGraph proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_cm_energy->proc~calc_pc2_exv proc~volume_integrate math_integrate::volume_integrate proc~calc_pc2_exv->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_cm_energy~~CalledByGraph proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_observables main::calc_observables proc~calc_observables->proc~calc_cm_energy proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_cm_energy.html"},{"title":"calc_Coulomb_Energy – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_Coulomb_Energy() Uses global_variables math_integrate proc~~calc_coulomb_energy~~UsesGraph proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy module~global_variables global_variables proc~calc_coulomb_energy->module~global_variables module~math_integrate math_integrate proc~calc_coulomb_energy->module~math_integrate iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~math_integrate->iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_coulomb_energy~~CallsGraph proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~volume_integrate math_integrate::volume_integrate proc~calc_coulomb_energy->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_coulomb_energy~~CalledByGraph proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_observables main::calc_observables proc~calc_observables->proc~calc_coulomb_energy proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_coulomb_energy.html"},{"title":"calc_Kinetic_Energy_by_integrate – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_Kinetic_Energy_by_integrate() Uses math_integrate global_variables constants_and_parameters proc~~calc_kinetic_energy_by_integrate~~UsesGraph proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate module~constants_and_parameters constants_and_parameters proc~calc_kinetic_energy_by_integrate->module~constants_and_parameters module~global_variables global_variables proc~calc_kinetic_energy_by_integrate->module~global_variables module~math_integrate math_integrate proc~calc_kinetic_energy_by_integrate->module~math_integrate iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_kinetic_energy_by_integrate~~CallsGraph proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~volume_integrate math_integrate::volume_integrate proc~calc_kinetic_energy_by_integrate->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_kinetic_energy_by_integrate~~CalledByGraph proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_observables main::calc_observables proc~calc_observables->proc~calc_kinetic_energy_by_integrate proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_kinetic_energy_by_integrate.html"},{"title":"calc_Skyrme_Energy_by_integrate – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_Skyrme_Energy_by_integrate() Uses math_integrate global_variables iso_fortran_env constants_and_parameters proc~~calc_skyrme_energy_by_integrate~~UsesGraph proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate iso_fortran_env iso_fortran_env proc~calc_skyrme_energy_by_integrate->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_skyrme_energy_by_integrate->module~constants_and_parameters module~global_variables global_variables proc~calc_skyrme_energy_by_integrate->module~global_variables module~math_integrate math_integrate proc~calc_skyrme_energy_by_integrate->module~math_integrate module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_skyrme_energy_by_integrate~~CallsGraph proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~volume_integrate math_integrate::volume_integrate proc~calc_skyrme_energy_by_integrate->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_skyrme_energy_by_integrate~~CalledByGraph proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_observables main::calc_observables proc~calc_observables->proc~calc_skyrme_energy_by_integrate proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_skyrme_energy_by_integrate.html"},{"title":"calc_Total_Energy – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine calc_Total_Energy() Uses global_variables proc~~calc_total_energy~~UsesGraph proc~calc_total_energy determine_observables::calc_Total_Energy module~global_variables global_variables proc~calc_total_energy->module~global_variables iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~calc_total_energy~~CalledByGraph proc~calc_total_energy determine_observables::calc_Total_Energy proc~calc_observables main::calc_observables proc~calc_observables->proc~calc_total_energy proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_total_energy.html"},{"title":"get_k – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function get_k(r_idx, z_idx) result(k_idx) Uses constants_and_parameters proc~~get_k~~UsesGraph proc~get_k poisson_problem::get_k module~constants_and_parameters constants_and_parameters proc~get_k->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: r_idx integer, intent(in) :: z_idx Return Value integer Called by proc~~get_k~~CalledByGraph proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~nine_point_poisson_by_lapack->proc~get_k proc~three_point_poisson_by_lapack poisson_problem::three_point_poisson_by_lapack proc~three_point_poisson_by_lapack->proc~get_k proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->proc~calc_coulomb_pot proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_pot_u->proc~calc_pot_u_np proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_u proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/get_k.html"},{"title":"nine_point_poisson_by_lapack – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine nine_point_poisson_by_lapack(rho_p, coulomb) Uses global_variables iso_fortran_env constants_and_parameters proc~~nine_point_poisson_by_lapack~~UsesGraph proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack iso_fortran_env iso_fortran_env proc~nine_point_poisson_by_lapack->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~nine_point_poisson_by_lapack->module~constants_and_parameters module~global_variables global_variables proc~nine_point_poisson_by_lapack->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho_p (:,:) real(kind=real64), intent(out) :: coulomb (:,:) Calls proc~~nine_point_poisson_by_lapack~~CallsGraph proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack->proc~get_k proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack->proc~use_dgesv dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~nine_point_poisson_by_lapack~~CalledByGraph proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->proc~calc_coulomb_pot proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_pot_u->proc~calc_pot_u_np proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_u proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/nine_point_poisson_by_lapack.html"},{"title":"three_point_poisson_by_lapack – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine three_point_poisson_by_lapack(rho_p, A, b) Uses iso_fortran_env constants_and_parameters proc~~three_point_poisson_by_lapack~~UsesGraph proc~three_point_poisson_by_lapack poisson_problem::three_point_poisson_by_lapack iso_fortran_env iso_fortran_env proc~three_point_poisson_by_lapack->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~three_point_poisson_by_lapack->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho_p (:,:) real(kind=real64), intent(out) :: A (:,:) real(kind=real64), intent(out) :: b (:) Calls proc~~three_point_poisson_by_lapack~~CallsGraph proc~three_point_poisson_by_lapack poisson_problem::three_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~three_point_poisson_by_lapack->proc~get_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/three_point_poisson_by_lapack.html"},{"title":"use_DGESV – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine use_DGESV(N, A, b, res_x) Uses iso_fortran_env proc~~use_dgesv~~UsesGraph proc~use_dgesv poisson_problem::use_DGESV iso_fortran_env iso_fortran_env proc~use_dgesv->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=8), intent(in) :: A (:,:) real(kind=8), intent(in) :: b (:) real(kind=8), intent(out) :: res_x (:) Calls proc~~use_dgesv~~CallsGraph proc~use_dgesv poisson_problem::use_DGESV dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~use_dgesv~~CalledByGraph proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~nine_point_poisson_by_lapack->proc~use_dgesv proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->proc~calc_coulomb_pot proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_pot_u->proc~calc_pot_u_np proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->proc~calc_pot_u proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/use_dgesv.html"},{"title":"write_mat – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  subroutine write_mat(A, N) Uses iso_fortran_env proc~~write_mat~~UsesGraph proc~write_mat poisson_problem::write_mat iso_fortran_env iso_fortran_env proc~write_mat->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: A (:,:) integer, intent(in) :: N Contents","tags":"","loc":"proc/write_mat.html"},{"title":"prep_wf_overlap – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"function prep_wf_overlap(idx_1, idx_2, np_int) result(ovlp) Uses math_integrate global_variables iso_fortran_env proc~~prep_wf_overlap~~UsesGraph proc~prep_wf_overlap main::prep_wf_overlap iso_fortran_env iso_fortran_env proc~prep_wf_overlap->iso_fortran_env module~global_variables global_variables proc~prep_wf_overlap->module~global_variables module~math_integrate math_integrate proc~prep_wf_overlap->module~math_integrate module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~math_integrate->iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: idx_1 integer(kind=int32), intent(in) :: idx_2 integer(kind=int32), intent(in) :: np_int Return Value real(kind=real64) Calls proc~~prep_wf_overlap~~CallsGraph proc~prep_wf_overlap main::prep_wf_overlap proc~volume_integrate math_integrate::volume_integrate proc~prep_wf_overlap->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~prep_wf_overlap~~CalledByGraph proc~prep_wf_overlap main::prep_wf_overlap proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~schmidt_orthogonalization->proc~prep_wf_overlap proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~schmidt_orthogonalization proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/prep_wf_overlap.html"},{"title":"Schmidt_orthogonalization – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine Schmidt_orthogonalization(np_int) Uses global_variables constants_and_parameters proc~~schmidt_orthogonalization~~UsesGraph proc~schmidt_orthogonalization main::Schmidt_orthogonalization module~constants_and_parameters constants_and_parameters proc~schmidt_orthogonalization->module~constants_and_parameters module~global_variables global_variables proc~schmidt_orthogonalization->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: np_int Calls proc~~schmidt_orthogonalization~~CallsGraph proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~prep_wf_overlap main::prep_wf_overlap proc~schmidt_orthogonalization->proc~prep_wf_overlap proc~volume_integrate math_integrate::volume_integrate proc~prep_wf_overlap->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~schmidt_orthogonalization~~CalledByGraph proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~schmidt_orthogonalization proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/schmidt_orthogonalization.html"},{"title":"alloc_fields – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine alloc_fields() Uses global_variables iso_fortran_env constants_and_parameters proc~~alloc_fields~~UsesGraph proc~alloc_fields main::alloc_fields iso_fortran_env iso_fortran_env proc~alloc_fields->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~alloc_fields->module~constants_and_parameters module~global_variables global_variables proc~alloc_fields->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~alloc_fields~~CalledByGraph proc~alloc_fields main::alloc_fields program~main main program~main->proc~alloc_fields Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/alloc_fields.html"},{"title":"calc_Bpsi – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_Bpsi() Uses math_derivation global_variables iso_fortran_env constants_and_parameters proc~~calc_bpsi~~UsesGraph proc~calc_bpsi main::calc_Bpsi iso_fortran_env iso_fortran_env proc~calc_bpsi->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_bpsi->module~constants_and_parameters module~global_variables global_variables proc~calc_bpsi->module~global_variables module~math_derivation math_derivation proc~calc_bpsi->module~math_derivation module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_derivation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_bpsi~~CallsGraph proc~calc_bpsi main::calc_Bpsi interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_bpsi->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_bpsi->interface~math_diff_z_9point proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_bpsi~~CalledByGraph proc~calc_bpsi main::calc_Bpsi proc~calc_hpsi main::calc_Hpsi proc~calc_hpsi->proc~calc_bpsi proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_bpsi.html"},{"title":"calc_Hpsi – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_Hpsi() Uses global_variables iso_fortran_env constants_and_parameters proc~~calc_hpsi~~UsesGraph proc~calc_hpsi main::calc_Hpsi iso_fortran_env iso_fortran_env proc~calc_hpsi->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_hpsi->module~constants_and_parameters module~global_variables global_variables proc~calc_hpsi->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_hpsi~~CallsGraph proc~calc_hpsi main::calc_Hpsi proc~calc_bpsi main::calc_Bpsi proc~calc_hpsi->proc~calc_bpsi proc~calc_upsi main::calc_Upsi proc~calc_hpsi->proc~calc_upsi proc~calc_wpsi main::calc_Wpsi proc~calc_hpsi->proc~calc_wpsi interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_bpsi->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_bpsi->interface~math_diff_z_9point proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_hpsi~~CalledByGraph proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_hpsi.html"},{"title":"calc_Hpsi2 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_Hpsi2() Uses math_derivation global_variables iso_fortran_env constants_and_parameters proc~~calc_hpsi2~~UsesGraph proc~calc_hpsi2 main::calc_Hpsi2 iso_fortran_env iso_fortran_env proc~calc_hpsi2->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_hpsi2->module~constants_and_parameters module~global_variables global_variables proc~calc_hpsi2->module~global_variables module~math_derivation math_derivation proc~calc_hpsi2->module~math_derivation module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_derivation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_hpsi2~~CallsGraph proc~calc_hpsi2 main::calc_Hpsi2 interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_hpsi2->interface~math_diff_2r_9point interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_hpsi2->interface~math_diff_2z_9point interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_hpsi2->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_hpsi2->interface~math_diff_z_9point proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_hpsi2~~CalledByGraph proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_hpsi2.html"},{"title":"calc_IMAG_Evolution – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_IMAG_Evolution(np_int) Uses global_variables constants_and_parameters proc~~calc_imag_evolution~~UsesGraph proc~calc_imag_evolution main::calc_IMAG_Evolution module~constants_and_parameters constants_and_parameters proc~calc_imag_evolution->module~constants_and_parameters module~global_variables global_variables proc~calc_imag_evolution->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: np_int Called by proc~~calc_imag_evolution~~CalledByGraph proc~calc_imag_evolution main::calc_IMAG_Evolution proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_imag_evolution proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/calc_imag_evolution.html"},{"title":"calc_Upsi – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_Upsi() Uses global_variables iso_fortran_env constants_and_parameters proc~~calc_upsi~~UsesGraph proc~calc_upsi main::calc_Upsi iso_fortran_env iso_fortran_env proc~calc_upsi->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_upsi->module~constants_and_parameters module~global_variables global_variables proc~calc_upsi->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~calc_upsi~~CalledByGraph proc~calc_upsi main::calc_Upsi proc~calc_hpsi main::calc_Hpsi proc~calc_hpsi->proc~calc_upsi proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_upsi.html"},{"title":"calc_Wpsi – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_Wpsi() Uses global_variables iso_fortran_env constants_and_parameters proc~~calc_wpsi~~UsesGraph proc~calc_wpsi main::calc_Wpsi iso_fortran_env iso_fortran_env proc~calc_wpsi->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_wpsi->module~constants_and_parameters module~global_variables global_variables proc~calc_wpsi->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~calc_wpsi~~CalledByGraph proc~calc_wpsi main::calc_Wpsi proc~calc_hpsi main::calc_Hpsi proc~calc_hpsi->proc~calc_wpsi proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_wpsi.html"},{"title":"calc_densities – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_densities() Arguments None Calls proc~~calc_densities~~CallsGraph proc~calc_densities main::calc_densities proc~calc_density_and_lap main::calc_density_and_lap proc~calc_densities->proc~calc_density_and_lap proc~calc_kinetic_density main::calc_kinetic_density proc~calc_densities->proc~calc_kinetic_density proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_densities->proc~calc_spin_orbit_density_and_div interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_density_and_lap->interface~math_diff_2r_9point interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_density_and_lap->interface~math_diff_2z_9point interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_density_and_lap->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_density_and_lap->interface~math_diff_z_9point proc~volume_integrate math_integrate::volume_integrate proc~calc_density_and_lap->proc~volume_integrate proc~calc_spin_orbit_density_and_div->interface~math_diff_r_9point proc~calc_spin_orbit_density_and_div->interface~math_diff_z_9point proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_densities~~CalledByGraph proc~calc_densities main::calc_densities proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_densities program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_densities.html"},{"title":"calc_density_and_lap – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_density_and_lap() Uses global_variables iso_fortran_env math_integrate ieee_arithmetic constants_and_parameters math_derivation proc~~calc_density_and_lap~~UsesGraph proc~calc_density_and_lap main::calc_density_and_lap ieee_arithmetic ieee_arithmetic proc~calc_density_and_lap->ieee_arithmetic iso_fortran_env iso_fortran_env proc~calc_density_and_lap->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_density_and_lap->module~constants_and_parameters module~global_variables global_variables proc~calc_density_and_lap->module~global_variables module~math_derivation math_derivation proc~calc_density_and_lap->module~math_derivation module~math_integrate math_integrate proc~calc_density_and_lap->module~math_integrate module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_derivation->iso_fortran_env module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_density_and_lap~~CallsGraph proc~calc_density_and_lap main::calc_density_and_lap interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_density_and_lap->interface~math_diff_2r_9point interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_density_and_lap->interface~math_diff_2z_9point interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_density_and_lap->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_density_and_lap->interface~math_diff_z_9point proc~volume_integrate math_integrate::volume_integrate proc~calc_density_and_lap->proc~volume_integrate proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_density_and_lap~~CalledByGraph proc~calc_density_and_lap main::calc_density_and_lap proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_density_and_lap proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_densities program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_density_and_lap.html"},{"title":"calc_derivation_of_wavefunction – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_derivation_of_wavefunction() Uses math_derivation global_variables constants_and_parameters proc~~calc_derivation_of_wavefunction~~UsesGraph proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction module~constants_and_parameters constants_and_parameters proc~calc_derivation_of_wavefunction->module~constants_and_parameters module~global_variables global_variables proc~calc_derivation_of_wavefunction->module~global_variables module~math_derivation math_derivation proc~calc_derivation_of_wavefunction->module~math_derivation iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env module~math_derivation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. maxval(dble(prep_mag(prep,l)+1)/r_vec(i)*prep_wf_minus) maxval(-dble(prep_mag(prep,l))/r_vec(i)*prep_wf_plus) Arguments None Calls proc~~calc_derivation_of_wavefunction~~CallsGraph proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_derivation_of_wavefunction->interface~math_diff_2r_9point interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_derivation_of_wavefunction->interface~math_diff_2z_9point interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_derivation_of_wavefunction->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_derivation_of_wavefunction->interface~math_diff_z_9point proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_derivation_of_wavefunction~~CalledByGraph proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_derivation_of_wavefunction program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_derivation_of_wavefunction.html"},{"title":"calc_ground_state – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_ground_state() Uses write_to_file global_variables iso_fortran_env constants_and_parameters proc~~calc_ground_state~~UsesGraph proc~calc_ground_state main::calc_ground_state iso_fortran_env iso_fortran_env proc~calc_ground_state->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_ground_state->module~constants_and_parameters module~global_variables global_variables proc~calc_ground_state->module~global_variables module~write_to_file write_to_file proc~calc_ground_state->module~write_to_file module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~write_to_file->iso_fortran_env module~write_to_file->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_ground_state~~CallsGraph proc~calc_ground_state main::calc_ground_state proc~calc_densities main::calc_densities proc~calc_ground_state->proc~calc_densities proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_meanfield main::calc_meanfield proc~calc_ground_state->proc~calc_meanfield proc~calc_observables main::calc_observables proc~calc_ground_state->proc~calc_observables proc~copy_to_occupied_wf main::copy_to_occupied_wf proc~calc_ground_state->proc~copy_to_occupied_wf proc~write_d_wavefunction write_to_file::write_d_wavefunction proc~calc_ground_state->proc~write_d_wavefunction proc~write_density_and_derivative write_to_file::write_density_and_derivative proc~calc_ground_state->proc~write_density_and_derivative proc~write_iter_energy write_to_file::write_iter_Energy proc~calc_ground_state->proc~write_iter_energy proc~write_meanfield_energy write_to_file::write_meanfield_Energy proc~calc_ground_state->proc~write_meanfield_energy proc~write_pot write_to_file::write_pot proc~calc_ground_state->proc~write_pot proc~write_prep_sort write_to_file::write_prep_sort proc~calc_ground_state->proc~write_prep_sort proc~write_wavefunction write_to_file::write_wavefunction proc~calc_ground_state->proc~write_wavefunction proc~calc_density_and_lap main::calc_density_and_lap proc~calc_densities->proc~calc_density_and_lap proc~calc_kinetic_density main::calc_kinetic_density proc~calc_densities->proc~calc_kinetic_density proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_densities->proc~calc_spin_orbit_density_and_div interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_derivation_of_wavefunction->interface~math_diff_2r_9point interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_derivation_of_wavefunction->interface~math_diff_2z_9point interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_derivation_of_wavefunction->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_derivation_of_wavefunction->interface~math_diff_z_9point proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_imag_evolution main::calc_IMAG_Evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_imag_evolution proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_hf_by_imaginary_time_evolution->proc~calc_one_particle_energy proc~is_converge_for_one_e main::is_converge_for_one_E proc~calc_hf_by_imaginary_time_evolution->proc~is_converge_for_one_e proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~calc_hf_by_imaginary_time_evolution->proc~schmidt_orthogonalization proc~sort_energy_and_idx main::sort_energy_and_idx proc~calc_hf_by_imaginary_time_evolution->proc~sort_energy_and_idx proc~calc_pot_b determine_meanfield_potential::calc_pot_B proc~calc_meanfield->proc~calc_pot_b proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_meanfield->proc~calc_pot_u proc~calc_pot_w determine_meanfield_potential::calc_pot_W proc~calc_meanfield->proc~calc_pot_w proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_observables->proc~calc_cm_energy proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_observables->proc~calc_coulomb_energy proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_observables->proc~calc_kinetic_energy_by_integrate proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_observables->proc~calc_skyrme_energy_by_integrate proc~calc_total_energy determine_observables::calc_Total_Energy proc~calc_observables->proc~calc_total_energy proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_cm_energy->proc~calc_pc2_exv proc~volume_integrate math_integrate::volume_integrate proc~calc_coulomb_energy->proc~volume_integrate proc~calc_density_and_lap->interface~math_diff_2r_9point proc~calc_density_and_lap->interface~math_diff_2z_9point proc~calc_density_and_lap->interface~math_diff_r_9point proc~calc_density_and_lap->interface~math_diff_z_9point proc~calc_density_and_lap->proc~volume_integrate proc~calc_bpsi main::calc_Bpsi proc~calc_hpsi->proc~calc_bpsi proc~calc_upsi main::calc_Upsi proc~calc_hpsi->proc~calc_upsi proc~calc_wpsi main::calc_Wpsi proc~calc_hpsi->proc~calc_wpsi proc~calc_hpsi2->interface~math_diff_2r_9point proc~calc_hpsi2->interface~math_diff_2z_9point proc~calc_hpsi2->interface~math_diff_r_9point proc~calc_hpsi2->interface~math_diff_z_9point proc~calc_kinetic_energy_by_integrate->proc~volume_integrate proc~calc_one_particle_energy->proc~volume_integrate proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u->proc~calc_pot_u_np proc~calc_skyrme_energy_by_integrate->proc~volume_integrate proc~calc_spin_orbit_density_and_div->interface~math_diff_r_9point proc~calc_spin_orbit_density_and_div->interface~math_diff_z_9point proc~prep_wf_overlap main::prep_wf_overlap proc~schmidt_orthogonalization->proc~prep_wf_overlap proc~calc_bpsi->interface~math_diff_r_9point proc~calc_bpsi->interface~math_diff_z_9point proc~calc_pc2_exv->proc~volume_integrate b0pt b0pt proc~calc_pot_u_np->b0pt b0t b0t proc~calc_pot_u_np->b0t b1pt b1pt proc~calc_pot_u_np->b1pt b1t b1t proc~calc_pot_u_np->b1t b2pt b2pt proc~calc_pot_u_np->b2pt b2t b2t proc~calc_pot_u_np->b2t b3pt b3pt proc~calc_pot_u_np->b3pt b3pt2 b3pt2 proc~calc_pot_u_np->b3pt2 b3t b3t proc~calc_pot_u_np->b3t b4pt b4pt proc~calc_pot_u_np->b4pt b4t b4t proc~calc_pot_u_np->b4t proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_pot_u_np->proc~calc_coulomb_pot proc~write_u_term write_to_file::write_U_term proc~calc_pot_u_np->proc~write_u_term proc~prep_wf_overlap->proc~volume_integrate proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack->proc~get_k proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack->proc~use_dgesv dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_ground_state~~CalledByGraph proc~calc_ground_state main::calc_ground_state program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_ground_state.html"},{"title":"calc_hf_by_imaginary_time_evolution – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_hf_by_imaginary_time_evolution() Uses global_variables constants_and_parameters proc~~calc_hf_by_imaginary_time_evolution~~UsesGraph proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution module~constants_and_parameters constants_and_parameters proc~calc_hf_by_imaginary_time_evolution->module~constants_and_parameters module~global_variables global_variables proc~calc_hf_by_imaginary_time_evolution->module~global_variables iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_hf_by_imaginary_time_evolution~~CallsGraph proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_imag_evolution main::calc_IMAG_Evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_imag_evolution proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_hf_by_imaginary_time_evolution->proc~calc_one_particle_energy proc~is_converge_for_one_e main::is_converge_for_one_E proc~calc_hf_by_imaginary_time_evolution->proc~is_converge_for_one_e proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~calc_hf_by_imaginary_time_evolution->proc~schmidt_orthogonalization proc~sort_energy_and_idx main::sort_energy_and_idx proc~calc_hf_by_imaginary_time_evolution->proc~sort_energy_and_idx proc~calc_bpsi main::calc_Bpsi proc~calc_hpsi->proc~calc_bpsi proc~calc_upsi main::calc_Upsi proc~calc_hpsi->proc~calc_upsi proc~calc_wpsi main::calc_Wpsi proc~calc_hpsi->proc~calc_wpsi interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_hpsi2->interface~math_diff_2r_9point interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_hpsi2->interface~math_diff_2z_9point interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_hpsi2->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_hpsi2->interface~math_diff_z_9point proc~volume_integrate math_integrate::volume_integrate proc~calc_one_particle_energy->proc~volume_integrate proc~prep_wf_overlap main::prep_wf_overlap proc~schmidt_orthogonalization->proc~prep_wf_overlap proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc proc~calc_bpsi->interface~math_diff_r_9point proc~calc_bpsi->interface~math_diff_z_9point proc~prep_wf_overlap->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_hf_by_imaginary_time_evolution~~CalledByGraph proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_hf_by_imaginary_time_evolution.html"},{"title":"calc_kinetic_density – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_kinetic_density() Uses global_variables iso_fortran_env constants_and_parameters proc~~calc_kinetic_density~~UsesGraph proc~calc_kinetic_density main::calc_kinetic_density iso_fortran_env iso_fortran_env proc~calc_kinetic_density->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_kinetic_density->module~constants_and_parameters module~global_variables global_variables proc~calc_kinetic_density->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~calc_kinetic_density~~CalledByGraph proc~calc_kinetic_density main::calc_kinetic_density proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_kinetic_density proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_densities program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_kinetic_density.html"},{"title":"calc_meanfield – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_meanfield() Uses determine_meanfield_potential proc~~calc_meanfield~~UsesGraph proc~calc_meanfield main::calc_meanfield module~determine_meanfield_potential determine_meanfield_potential proc~calc_meanfield->module~determine_meanfield_potential module~constants_and_parameters constants_and_parameters module~determine_meanfield_potential->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_meanfield~~CallsGraph proc~calc_meanfield main::calc_meanfield proc~calc_pot_b determine_meanfield_potential::calc_pot_B proc~calc_meanfield->proc~calc_pot_b proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_meanfield->proc~calc_pot_u proc~calc_pot_w determine_meanfield_potential::calc_pot_W proc~calc_meanfield->proc~calc_pot_w proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u->proc~calc_pot_u_np b0pt b0pt proc~calc_pot_u_np->b0pt b0t b0t proc~calc_pot_u_np->b0t b1pt b1pt proc~calc_pot_u_np->b1pt b1t b1t proc~calc_pot_u_np->b1t b2pt b2pt proc~calc_pot_u_np->b2pt b2t b2t proc~calc_pot_u_np->b2t b3pt b3pt proc~calc_pot_u_np->b3pt b3pt2 b3pt2 proc~calc_pot_u_np->b3pt2 b3t b3t proc~calc_pot_u_np->b3t b4pt b4pt proc~calc_pot_u_np->b4pt b4t b4t proc~calc_pot_u_np->b4t proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_pot_u_np->proc~calc_coulomb_pot proc~write_u_term write_to_file::write_U_term proc~calc_pot_u_np->proc~write_u_term proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack->proc~get_k proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack->proc~use_dgesv dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_meanfield~~CalledByGraph proc~calc_meanfield main::calc_meanfield proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_meanfield program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_meanfield.html"},{"title":"calc_observables – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_observables() Uses determine_observables proc~~calc_observables~~UsesGraph proc~calc_observables main::calc_observables module~determine_observables determine_observables proc~calc_observables->module~determine_observables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_observables~~CallsGraph proc~calc_observables main::calc_observables proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_observables->proc~calc_cm_energy proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_observables->proc~calc_coulomb_energy proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_observables->proc~calc_kinetic_energy_by_integrate proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_observables->proc~calc_skyrme_energy_by_integrate proc~calc_total_energy determine_observables::calc_Total_Energy proc~calc_observables->proc~calc_total_energy proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_cm_energy->proc~calc_pc2_exv proc~volume_integrate math_integrate::volume_integrate proc~calc_coulomb_energy->proc~volume_integrate proc~calc_kinetic_energy_by_integrate->proc~volume_integrate proc~calc_skyrme_energy_by_integrate->proc~volume_integrate proc~calc_pc2_exv->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_observables~~CalledByGraph proc~calc_observables main::calc_observables proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_observables program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_observables.html"},{"title":"calc_one_particle_energy – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_one_particle_energy() Uses math_integrate global_variables iso_fortran_env constants_and_parameters proc~~calc_one_particle_energy~~UsesGraph proc~calc_one_particle_energy main::calc_one_particle_energy iso_fortran_env iso_fortran_env proc~calc_one_particle_energy->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_one_particle_energy->module~constants_and_parameters module~global_variables global_variables proc~calc_one_particle_energy->module~global_variables module~math_integrate math_integrate proc~calc_one_particle_energy->module~math_integrate module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_one_particle_energy~~CallsGraph proc~calc_one_particle_energy main::calc_one_particle_energy proc~volume_integrate math_integrate::volume_integrate proc~calc_one_particle_energy->proc~volume_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_one_particle_energy~~CalledByGraph proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_one_particle_energy proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_one_particle_energy.html"},{"title":"calc_spin_orbit_density_and_div – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine calc_spin_orbit_density_and_div() Uses global_variables iso_fortran_env ieee_arithmetic constants_and_parameters math_derivation proc~~calc_spin_orbit_density_and_div~~UsesGraph proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div ieee_arithmetic ieee_arithmetic proc~calc_spin_orbit_density_and_div->ieee_arithmetic iso_fortran_env iso_fortran_env proc~calc_spin_orbit_density_and_div->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~calc_spin_orbit_density_and_div->module~constants_and_parameters module~global_variables global_variables proc~calc_spin_orbit_density_and_div->module~global_variables module~math_derivation math_derivation proc~calc_spin_orbit_density_and_div->module~math_derivation module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_derivation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~calc_spin_orbit_density_and_div~~CallsGraph proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_spin_orbit_density_and_div->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_spin_orbit_density_and_div->interface~math_diff_z_9point proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_spin_orbit_density_and_div~~CalledByGraph proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_densities main::calc_densities proc~calc_densities->proc~calc_spin_orbit_density_and_div proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_densities program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_spin_orbit_density_and_div.html"},{"title":"copy_to_occupied_wf – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine copy_to_occupied_wf() Uses math_derivation global_variables constants_and_parameters proc~~copy_to_occupied_wf~~UsesGraph proc~copy_to_occupied_wf main::copy_to_occupied_wf module~constants_and_parameters constants_and_parameters proc~copy_to_occupied_wf->module~constants_and_parameters module~global_variables global_variables proc~copy_to_occupied_wf->module~global_variables module~math_derivation math_derivation proc~copy_to_occupied_wf->module~math_derivation iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env module~global_variables->module~constants_and_parameters module~global_variables->iso_fortran_env module~math_derivation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~copy_to_occupied_wf~~CalledByGraph proc~copy_to_occupied_wf main::copy_to_occupied_wf proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~copy_to_occupied_wf program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/copy_to_occupied_wf.html"},{"title":"dealloc_fields – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine dealloc_fields() Uses global_variables proc~~dealloc_fields~~UsesGraph proc~dealloc_fields main::dealloc_fields module~global_variables global_variables proc~dealloc_fields->module~global_variables iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~dealloc_fields~~CalledByGraph proc~dealloc_fields main::dealloc_fields program~main main program~main->proc~dealloc_fields Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dealloc_fields.html"},{"title":"initial_settings – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine initial_settings() Uses global_variables iso_fortran_env proc~~initial_settings~~UsesGraph proc~initial_settings main::initial_settings iso_fortran_env iso_fortran_env proc~initial_settings->iso_fortran_env module~global_variables global_variables proc~initial_settings->module~global_variables module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~initial_settings~~CallsGraph proc~initial_settings main::initial_settings proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~initial_settings->proc~prep_initial_wavefunction proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~initial_settings->proc~prep_time_reversal_wavefunction proc~calc_occ_energy harmonic_occ_wf::calc_occ_energy proc~prep_initial_wavefunction->proc~calc_occ_energy proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~prep_initial_wavefunction->proc~set_harmonic_occ proc~sort_energy_and_idx main::sort_energy_and_idx proc~prep_initial_wavefunction->proc~sort_energy_and_idx proc~prep_time_reversal_wavefunction->proc~calc_occ_energy proc~prep_time_reversal_wavefunction->proc~set_harmonic_occ proc~prep_time_reversal_wavefunction->proc~sort_energy_and_idx proc~hermite_n spacial_function::Hermite_n proc~set_harmonic_occ->proc~hermite_n proc~laguerre_nl spacial_function::Laguerre_nl proc~set_harmonic_occ->proc~laguerre_nl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initial_settings~~CalledByGraph proc~initial_settings main::initial_settings program~main main program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initial_settings.html"},{"title":"is_converge_for_one_E – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine is_converge_for_one_E(is_converged) Uses math_integrate global_variables iso_fortran_env constants_and_parameters proc~~is_converge_for_one_e~~UsesGraph proc~is_converge_for_one_e main::is_converge_for_one_E iso_fortran_env iso_fortran_env proc~is_converge_for_one_e->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~is_converge_for_one_e->module~constants_and_parameters module~global_variables global_variables proc~is_converge_for_one_e->module~global_variables module~math_integrate math_integrate proc~is_converge_for_one_e->module~math_integrate module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name logical, intent(out) :: is_converged Called by proc~~is_converge_for_one_e~~CalledByGraph proc~is_converge_for_one_e main::is_converge_for_one_E proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~is_converge_for_one_e proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution program~main main program~main->proc~calc_ground_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/is_converge_for_one_e.html"},{"title":"prep_initial_wavefunction – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine prep_initial_wavefunction() Uses harmonic_occ_wf global_variables math_integrate iso_fortran_env constants_and_parameters proc~~prep_initial_wavefunction~~UsesGraph proc~prep_initial_wavefunction main::prep_initial_wavefunction iso_fortran_env iso_fortran_env proc~prep_initial_wavefunction->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~prep_initial_wavefunction->module~constants_and_parameters module~global_variables global_variables proc~prep_initial_wavefunction->module~global_variables module~harmonic_occ_wf harmonic_occ_wf proc~prep_initial_wavefunction->module~harmonic_occ_wf module~math_integrate math_integrate proc~prep_initial_wavefunction->module~math_integrate module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~harmonic_occ_wf->iso_fortran_env module~harmonic_occ_wf->module~constants_and_parameters module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. !!!!--------- prep_numberも変更してます -----------！！！！！！！！！！！ Arguments None Calls proc~~prep_initial_wavefunction~~CallsGraph proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~calc_occ_energy harmonic_occ_wf::calc_occ_energy proc~prep_initial_wavefunction->proc~calc_occ_energy proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~prep_initial_wavefunction->proc~set_harmonic_occ proc~sort_energy_and_idx main::sort_energy_and_idx proc~prep_initial_wavefunction->proc~sort_energy_and_idx proc~hermite_n spacial_function::Hermite_n proc~set_harmonic_occ->proc~hermite_n proc~laguerre_nl spacial_function::Laguerre_nl proc~set_harmonic_occ->proc~laguerre_nl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~prep_initial_wavefunction~~CalledByGraph proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~initial_settings main::initial_settings proc~initial_settings->proc~prep_initial_wavefunction program~main main program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prep_initial_wavefunction.html"},{"title":"prep_time_reversal_wavefunction – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine prep_time_reversal_wavefunction() Uses harmonic_occ_wf global_variables math_integrate iso_fortran_env constants_and_parameters proc~~prep_time_reversal_wavefunction~~UsesGraph proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction iso_fortran_env iso_fortran_env proc~prep_time_reversal_wavefunction->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~prep_time_reversal_wavefunction->module~constants_and_parameters module~global_variables global_variables proc~prep_time_reversal_wavefunction->module~global_variables module~harmonic_occ_wf harmonic_occ_wf proc~prep_time_reversal_wavefunction->module~harmonic_occ_wf module~math_integrate math_integrate proc~prep_time_reversal_wavefunction->module~math_integrate module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters module~harmonic_occ_wf->iso_fortran_env module~harmonic_occ_wf->module~constants_and_parameters module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~prep_time_reversal_wavefunction~~CallsGraph proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~calc_occ_energy harmonic_occ_wf::calc_occ_energy proc~prep_time_reversal_wavefunction->proc~calc_occ_energy proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~prep_time_reversal_wavefunction->proc~set_harmonic_occ proc~sort_energy_and_idx main::sort_energy_and_idx proc~prep_time_reversal_wavefunction->proc~sort_energy_and_idx proc~hermite_n spacial_function::Hermite_n proc~set_harmonic_occ->proc~hermite_n proc~laguerre_nl spacial_function::Laguerre_nl proc~set_harmonic_occ->proc~laguerre_nl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~prep_time_reversal_wavefunction~~CalledByGraph proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~initial_settings main::initial_settings proc~initial_settings->proc~prep_time_reversal_wavefunction program~main main program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prep_time_reversal_wavefunction.html"},{"title":"read_input_parameters – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine read_input_parameters() Uses global_variables iso_fortran_env constants_and_parameters proc~~read_input_parameters~~UsesGraph proc~read_input_parameters main::read_input_parameters iso_fortran_env iso_fortran_env proc~read_input_parameters->iso_fortran_env module~constants_and_parameters constants_and_parameters proc~read_input_parameters->module~constants_and_parameters module~global_variables global_variables proc~read_input_parameters->module~global_variables module~constants_and_parameters->iso_fortran_env module~global_variables->iso_fortran_env module~global_variables->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Called by proc~~read_input_parameters~~CalledByGraph proc~read_input_parameters main::read_input_parameters program~main main program~main->proc~read_input_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_input_parameters.html"},{"title":"sort_energy_and_idx – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"subroutine sort_energy_and_idx(energy_array, idx) Uses iso_fortran_env proc~~sort_energy_and_idx~~UsesGraph proc~sort_energy_and_idx main::sort_energy_and_idx iso_fortran_env iso_fortran_env proc~sort_energy_and_idx->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: energy_array (:,:) integer(kind=int32), intent(inout) :: idx (:,:) Called by proc~~sort_energy_and_idx~~CalledByGraph proc~sort_energy_and_idx main::sort_energy_and_idx proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->proc~sort_energy_and_idx proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->proc~sort_energy_and_idx proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->proc~sort_energy_and_idx proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~initial_settings main::initial_settings proc~initial_settings->proc~prep_initial_wavefunction proc~initial_settings->proc~prep_time_reversal_wavefunction program~main main program~main->proc~calc_ground_state program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/sort_energy_and_idx.html"},{"title":"calc_occ_energy – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function calc_occ_energy(node_r, node_z, mag, betain) result(occ_energy) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: node_r integer(kind=int32), intent(in) :: node_z integer(kind=int32), intent(in) :: mag real(kind=real64), intent(in) :: betain Return Value real(kind=real64) Called by proc~~calc_occ_energy~~CalledByGraph proc~calc_occ_energy harmonic_occ_wf::calc_occ_energy proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->proc~calc_occ_energy proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->proc~calc_occ_energy proc~initial_settings main::initial_settings proc~initial_settings->proc~prep_initial_wavefunction proc~initial_settings->proc~prep_time_reversal_wavefunction program~main main program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/calc_occ_energy.html"},{"title":"set_harmonic_occ – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"public  function set_harmonic_occ(node_r, node_z, mag, r, z, betain) result(normilized_wf) Uses global_variables spacial_function proc~~set_harmonic_occ~~UsesGraph proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ module~global_variables global_variables proc~set_harmonic_occ->module~global_variables module~spacial_function spacial_function proc~set_harmonic_occ->module~spacial_function iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~spacial_function->iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: node_r integer(kind=int32), intent(in) :: node_z integer(kind=int32), intent(in) :: mag real(kind=real64), intent(in) :: r real(kind=real64), intent(in) :: z real(kind=real64), intent(in) :: betain Return Value real(kind=real64) Calls proc~~set_harmonic_occ~~CallsGraph proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~hermite_n spacial_function::Hermite_n proc~set_harmonic_occ->proc~hermite_n proc~laguerre_nl spacial_function::Laguerre_nl proc~set_harmonic_occ->proc~laguerre_nl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_harmonic_occ~~CalledByGraph proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->proc~set_harmonic_occ proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->proc~set_harmonic_occ proc~initial_settings main::initial_settings proc~initial_settings->proc~prep_initial_wavefunction proc~initial_settings->proc~prep_time_reversal_wavefunction program~main main program~main->proc~initial_settings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/set_harmonic_occ.html"},{"title":"determine_meanfield_potential – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses constants_and_parameters module~~determine_meanfield_potential~~UsesGraph module~determine_meanfield_potential determine_meanfield_potential module~constants_and_parameters constants_and_parameters module~determine_meanfield_potential->module~constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~determine_meanfield_potential~~UsedByGraph module~determine_meanfield_potential determine_meanfield_potential proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->module~determine_meanfield_potential Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines calc_Woods_Saxon calc_coulomb_pot calc_pot_B calc_pot_U calc_pot_U_np calc_pot_W Subroutines public  subroutine calc_Woods_Saxon () Arguments None public  subroutine calc_coulomb_pot () Arguments None public  subroutine calc_pot_B () Arguments None public  subroutine calc_pot_U () Arguments None public  subroutine calc_pot_U_np (np_str, is_coulomb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: np_str logical, intent(in), optional :: is_coulomb public  subroutine calc_pot_W () Arguments None","tags":"","loc":"module/determine_meanfield_potential.html"},{"title":"math_derivation – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses iso_fortran_env module~~math_derivation~~UsesGraph module~math_derivation math_derivation iso_fortran_env iso_fortran_env module~math_derivation->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~math_derivation~~UsedByGraph module~math_derivation math_derivation proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->module~math_derivation proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->module~math_derivation proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->module~math_derivation proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->module~math_derivation proc~calc_pot_w determine_meanfield_potential::calc_pot_W proc~calc_pot_w->module~math_derivation proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->module~math_derivation proc~copy_to_occupied_wf main::copy_to_occupied_wf proc~copy_to_occupied_wf->module~math_derivation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables eps Interfaces math_diff_2r_9point math_diff_2z_9point math_diff_r_9point math_diff_z_9point Functions math_diff_2r_9point_realfunc math_diff_2z_9point_realfunc math_diff_r_9point_complexfunc math_diff_r_9point_realfunc math_diff_z_9point_complexfunc math_diff_z_9point_realfunc Variables Type Visibility Attributes Name Initial real(kind=real64), public :: eps = 0.03d0 Interfaces public        interface math_diff_2r_9point public  function math_diff_2r_9point_realfunc (f) result(f_2r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public        interface math_diff_2z_9point public  function math_diff_2z_9point_realfunc (f) result(f_2z) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public        interface math_diff_r_9point public  function math_diff_r_9point_realfunc (f) result(f_r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public  function math_diff_r_9point_complexfunc (f) result(f_r) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:) public        interface math_diff_z_9point public  function math_diff_z_9point_realfunc (f) result(f_z) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public  function math_diff_z_9point_complexfunc (f) result(f_z) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:) Functions public  function math_diff_2r_9point_realfunc (f) result(f_2r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public  function math_diff_2z_9point_realfunc (f) result(f_2z) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public  function math_diff_r_9point_complexfunc (f) result(f_r) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:) public  function math_diff_r_9point_realfunc (f) result(f_r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:) public  function math_diff_z_9point_complexfunc (f) result(f_z) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: f (:,:) Return Value complex(kind=real64), allocatable, (:,:) public  function math_diff_z_9point_realfunc (f) result(f_z) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64), allocatable, (:,:)","tags":"","loc":"module/math_derivation.html"},{"title":"spacial_function – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses iso_fortran_env module~~spacial_function~~UsesGraph module~spacial_function spacial_function iso_fortran_env iso_fortran_env module~spacial_function->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~spacial_function~~UsedByGraph module~spacial_function spacial_function proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~set_harmonic_occ->module~spacial_function Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions Hermite_n Laguerre_nl Functions public  function Hermite_n (n, x) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: x Return Value real(kind=real64) public  function Laguerre_nl (n, l, x) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: l real(kind=real64), intent(in) :: x Return Value real(kind=real64)","tags":"","loc":"module/spacial_function.html"},{"title":"constants_and_parameters – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses iso_fortran_env module~~constants_and_parameters~~UsesGraph module~constants_and_parameters constants_and_parameters iso_fortran_env iso_fortran_env module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~constants_and_parameters~~UsedByGraph module~constants_and_parameters constants_and_parameters module~determine_meanfield_potential determine_meanfield_potential module~determine_meanfield_potential->module~constants_and_parameters module~global_variables global_variables module~global_variables->module~constants_and_parameters module~harmonic_occ_wf harmonic_occ_wf module~harmonic_occ_wf->module~constants_and_parameters module~write_to_file write_to_file module~write_to_file->module~constants_and_parameters proc~alloc_fields main::alloc_fields proc~alloc_fields->module~constants_and_parameters proc~alloc_fields->module~global_variables proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->module~constants_and_parameters proc~calc_bpsi->module~global_variables proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_cm_energy->module~constants_and_parameters proc~calc_cm_energy->module~global_variables proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->module~constants_and_parameters proc~calc_density_and_lap->module~global_variables proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->module~constants_and_parameters proc~calc_derivation_of_wavefunction->module~global_variables proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->module~constants_and_parameters proc~calc_ground_state->module~global_variables proc~calc_ground_state->module~write_to_file proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->module~constants_and_parameters proc~calc_hf_by_imaginary_time_evolution->module~global_variables proc~calc_hpsi main::calc_Hpsi proc~calc_hpsi->module~constants_and_parameters proc~calc_hpsi->module~global_variables proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->module~constants_and_parameters proc~calc_hpsi2->module~global_variables proc~calc_imag_evolution main::calc_IMAG_Evolution proc~calc_imag_evolution->module~constants_and_parameters proc~calc_imag_evolution->module~global_variables proc~calc_kinetic_density main::calc_kinetic_density proc~calc_kinetic_density->module~constants_and_parameters proc~calc_kinetic_density->module~global_variables proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_kinetic_energy_by_integrate->module~constants_and_parameters proc~calc_kinetic_energy_by_integrate->module~global_variables proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_one_particle_energy->module~constants_and_parameters proc~calc_one_particle_energy->module~global_variables proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_pc2_exv->module~constants_and_parameters proc~calc_pc2_exv->module~global_variables proc~calc_pot_b determine_meanfield_potential::calc_pot_B proc~calc_pot_b->module~constants_and_parameters proc~calc_pot_b->module~global_variables proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->module~constants_and_parameters proc~calc_pot_u_np->module~global_variables proc~calc_pot_u_np->module~write_to_file proc~calc_pot_w determine_meanfield_potential::calc_pot_W proc~calc_pot_w->module~constants_and_parameters proc~calc_pot_w->module~global_variables proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_skyrme_energy_by_integrate->module~constants_and_parameters proc~calc_skyrme_energy_by_integrate->module~global_variables proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->module~constants_and_parameters proc~calc_spin_orbit_density_and_div->module~global_variables proc~calc_upsi main::calc_Upsi proc~calc_upsi->module~constants_and_parameters proc~calc_upsi->module~global_variables proc~calc_woods_saxon determine_meanfield_potential::calc_Woods_Saxon proc~calc_woods_saxon->module~constants_and_parameters proc~calc_woods_saxon->module~global_variables proc~calc_wpsi main::calc_Wpsi proc~calc_wpsi->module~constants_and_parameters proc~calc_wpsi->module~global_variables proc~copy_to_occupied_wf main::copy_to_occupied_wf proc~copy_to_occupied_wf->module~constants_and_parameters proc~copy_to_occupied_wf->module~global_variables proc~get_k poisson_problem::get_k proc~get_k->module~constants_and_parameters proc~is_converge_for_one_e main::is_converge_for_one_E proc~is_converge_for_one_e->module~constants_and_parameters proc~is_converge_for_one_e->module~global_variables proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc proc~math_diff_2r_9point_realfunc->module~constants_and_parameters proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc proc~math_diff_2z_9point_realfunc->module~constants_and_parameters proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc proc~math_diff_r_9point_complexfunc->module~constants_and_parameters proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc proc~math_diff_r_9point_realfunc->module~constants_and_parameters proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc proc~math_diff_z_9point_complexfunc->module~constants_and_parameters proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc proc~math_diff_z_9point_realfunc->module~constants_and_parameters proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~nine_point_poisson_by_lapack->module~constants_and_parameters proc~nine_point_poisson_by_lapack->module~global_variables proc~outputsettings write_to_file::outputsettings proc~outputsettings->module~constants_and_parameters proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->module~constants_and_parameters proc~prep_initial_wavefunction->module~global_variables proc~prep_initial_wavefunction->module~harmonic_occ_wf proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->module~constants_and_parameters proc~prep_time_reversal_wavefunction->module~global_variables proc~prep_time_reversal_wavefunction->module~harmonic_occ_wf proc~read_input_parameters main::read_input_parameters proc~read_input_parameters->module~constants_and_parameters proc~read_input_parameters->module~global_variables proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~schmidt_orthogonalization->module~constants_and_parameters proc~schmidt_orthogonalization->module~global_variables proc~sympson_volume_integrate math_integrate::sympson_volume_integrate proc~sympson_volume_integrate->module~constants_and_parameters proc~sympson_volume_integrate->module~global_variables proc~three_point_poisson_by_lapack poisson_problem::three_point_poisson_by_lapack proc~three_point_poisson_by_lapack->module~constants_and_parameters proc~volume_integrate math_integrate::volume_integrate proc~volume_integrate->module~constants_and_parameters proc~volume_integrate->module~global_variables proc~write_d_wavefunction write_to_file::write_d_wavefunction proc~write_d_wavefunction->module~constants_and_parameters proc~write_d_wavefunction->module~global_variables proc~write_density_and_derivative write_to_file::write_density_and_derivative proc~write_density_and_derivative->module~constants_and_parameters proc~write_density_and_derivative->module~global_variables proc~write_pot write_to_file::write_pot proc~write_pot->module~constants_and_parameters proc~write_pot->module~global_variables proc~write_prep_sort write_to_file::write_prep_sort proc~write_prep_sort->module~constants_and_parameters proc~write_prep_sort->module~global_variables proc~write_u_term write_to_file::write_U_term proc~write_u_term->module~constants_and_parameters proc~write_u_term->module~global_variables proc~write_wavefunction write_to_file::write_wavefunction proc~write_wavefunction->module~constants_and_parameters proc~write_wavefunction->module~global_variables program~main main program~main->module~constants_and_parameters program~main->module~write_to_file proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_coulomb_energy->module~global_variables proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_coulomb_pot->module~global_variables proc~calc_meanfield main::calc_meanfield proc~calc_meanfield->module~determine_meanfield_potential proc~calc_total_energy determine_observables::calc_Total_Energy proc~calc_total_energy->module~global_variables proc~dealloc_fields main::dealloc_fields proc~dealloc_fields->module~global_variables proc~initial_settings main::initial_settings proc~initial_settings->module~global_variables proc~overlap_to_file write_to_file::overlap_to_file proc~overlap_to_file->module~global_variables proc~prep_wf_overlap main::prep_wf_overlap proc~prep_wf_overlap->module~global_variables proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~set_harmonic_occ->module~global_variables proc~write_iter_energy write_to_file::write_iter_Energy proc~write_iter_energy->module~global_variables proc~write_meanfield_energy write_to_file::write_meanfield_Energy proc~write_meanfield_energy->module~global_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables HBAR2_over_2m HBARC MMDDHHMMSS Nr Nz PI SD_eps b_0 b_0p b_1 b_1p b_2 b_2p b_3 b_3p b_4 b_4p c_1 c_1p cou_eps coulomb_updated_flag date deformation_degree dr dz elementary_charge2 eta fine_structure foldername imaginary_time_step imaginary_unit is_TimeR is_converged is_coulomb is_minus_var is_output is_update_coulomb is_use_B is_use_W is_use_dd is_use_second_imag lagrange_multiplier mass_of_neutron mass_of_proton max_iter not_divJ nuc_name num_n num_p param_gamma plot_iter prep_max_m prep_max_r prep_max_z prep_number prev_eps r_max resultdir str_z t_0 t_1 t_2 t_3 t_4 time x_0 x_1 x_2 x_3 z_center z_max Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: HBAR2_over_2m = 20.75250d0 real(kind=real64), public, parameter :: HBARC = 197.32705d0 character(len=12), public :: MMDDHHMMSS integer(kind=int32), public :: Nr = 100 integer(kind=int32), public :: Nz = 100 real(kind=real64), public, parameter :: PI = 4.0d0*atan(1.0d0) real(kind=real64), public :: SD_eps = 1d-6 real(kind=real64), public, parameter :: b_0 = t_0*(1d0+x_0/2d0) real(kind=real64), public, parameter :: b_0p = t_0*(1d0/2d0+x_0) real(kind=real64), public, parameter :: b_1 = 1d0/4d0*(t_1*(1d0+x_1/2d0)+t_2*(1d0+x_2/2d0)) real(kind=real64), public, parameter :: b_1p = 1d0/4d0*(t_1*(1d0/2d0+x_1)-t_2*(1d0/2d0+x_2)) real(kind=real64), public, parameter :: b_2 = 1d0/8d0*(3d0*t_1*(1d0+x_1/2d0)-t_2*(1d0+x_2/2d0)) real(kind=real64), public, parameter :: b_2p = 1d0/8d0*(3d0*t_1*(1d0/2d0+x_1)+t_2*(1d0/2d0+x_2)) real(kind=real64), public, parameter :: b_3 = 1d0/4d0*t_3*(1d0+x_3/2d0) real(kind=real64), public, parameter :: b_3p = 1d0/4d0*t_3*(1d0/2d0+x_3) real(kind=real64), public, parameter :: b_4 = t_4/2d0 real(kind=real64), public, parameter :: b_4p = t_4/2d0 real(kind=real64), public, parameter :: c_1 = eta*1d0/16d0*(t_1*x_1+t_2*x_2) real(kind=real64), public, parameter :: c_1p = eta*1d0/16d0*(t_1-t_2) real(kind=real64), public :: cou_eps = 1d0 logical, public :: coulomb_updated_flag = .false. character(len=8), public :: date real(kind=real64), public, parameter :: deformation_degree = 0.0d0 real(kind=real64), public :: dr real(kind=real64), public :: dz real(kind=real64), public, parameter :: elementary_charge2 = HBARC*fine_structure real(kind=real64), public, parameter :: eta = 1d0 real(kind=real64), public, parameter :: fine_structure = 1d0/137.04d0 character(len=21), public :: foldername real(kind=real64), public :: imaginary_time_step = 1d-2 complex(kind=real64), public, parameter :: imaginary_unit = (0.0d0, 1.0d0) logical, public :: is_TimeR = .true. logical, public :: is_converged = .false. logical, public :: is_coulomb = .false. logical, public :: is_minus_var = .false. logical, public :: is_output = .true. logical, public :: is_update_coulomb = .true. logical, public :: is_use_B = .true. logical, public :: is_use_W = .true. logical, public :: is_use_dd = .true. logical, public :: is_use_second_imag = .false. real(kind=real64), public :: lagrange_multiplier = 1d0 real(kind=real64), public, parameter :: mass_of_neutron = 939.565413d0 real(kind=real64), public, parameter :: mass_of_proton = 938.272088d0 integer(kind=int32), public :: max_iter = 5000 logical, public :: not_divJ = .true. character(len=8), public :: nuc_name integer(kind=int32), public :: num_n = 2 integer(kind=int32), public :: num_p = 2 real(kind=real64), public, parameter :: param_gamma = 1.0d0/6.0d0 integer(kind=int32), public :: plot_iter = 500 integer(kind=int32), public :: prep_max_m = 3 integer(kind=int32), public :: prep_max_r = 3 integer(kind=int32), public :: prep_max_z = 3 integer(kind=int32), public :: prep_number = 2 real(kind=real64), public :: prev_eps = 1d-12 real(kind=real64), public, parameter :: r_max = 20d0 character(len=9), public, parameter :: resultdir = \"./../res/\" character(len=8), public :: str_z real(kind=real64), public, parameter :: t_0 = -2645.0d0 real(kind=real64), public, parameter :: t_1 = 410.0d0 real(kind=real64), public, parameter :: t_2 = -135.0d0 real(kind=real64), public, parameter :: t_3 = 15595.0d0 real(kind=real64), public, parameter :: t_4 = 130.0d0 character(len=10), public :: time real(kind=real64), public, parameter :: x_0 = 0.090d0 real(kind=real64), public, parameter :: x_1 = 0.0d0 real(kind=real64), public, parameter :: x_2 = 0.0d0 real(kind=real64), public, parameter :: x_3 = 0.0d0 real(kind=real64), public :: z_center = z_max/2d0 real(kind=real64), public, parameter :: z_max = 20d0","tags":"","loc":"module/constants_and_parameters.html"},{"title":"math_integrate – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses iso_fortran_env module~~math_integrate~~UsesGraph module~math_integrate math_integrate iso_fortran_env iso_fortran_env module~math_integrate->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~math_integrate~~UsedByGraph module~math_integrate math_integrate proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_coulomb_energy->module~math_integrate proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->module~math_integrate proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_kinetic_energy_by_integrate->module~math_integrate proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_one_particle_energy->module~math_integrate proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_pc2_exv->module~math_integrate proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_skyrme_energy_by_integrate->module~math_integrate proc~is_converge_for_one_e main::is_converge_for_one_E proc~is_converge_for_one_e->module~math_integrate proc~overlap_to_file write_to_file::overlap_to_file proc~overlap_to_file->module~math_integrate proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->module~math_integrate proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->module~math_integrate proc~prep_wf_overlap main::prep_wf_overlap proc~prep_wf_overlap->module~math_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions sympson_volume_integrate volume_integrate Functions public  function sympson_volume_integrate (f) result(result) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64) public  function volume_integrate (f) result(result) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: f (:,:) Return Value real(kind=real64)","tags":"","loc":"module/math_integrate.html"},{"title":"write_to_file – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses iso_fortran_env constants_and_parameters module~~write_to_file~~UsesGraph module~write_to_file write_to_file iso_fortran_env iso_fortran_env module~write_to_file->iso_fortran_env module~constants_and_parameters constants_and_parameters module~write_to_file->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~write_to_file~~UsedByGraph module~write_to_file write_to_file proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->module~write_to_file proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->module~write_to_file program~main main program~main->module~write_to_file Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions overlap_to_file Subroutines make_one_file outputsettings write_U_term write_d_wavefunction write_density_and_derivative write_iter_Energy write_meanfield_Energy write_pot write_prep_sort write_wavefunction Functions public  function overlap_to_file (idx_1, idx_2) result(ovlp) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: idx_1 integer(kind=int32), intent(in) :: idx_2 Return Value real(kind=real64) Subroutines public  subroutine make_one_file (filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename public  subroutine outputsettings () Arguments None public  subroutine write_U_term (b0, b0p, b1, b1p, b2, b2p, b3, b3p, b3p2, b4, b4p, dir, ex, np_str) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: b0 (:,:) real(kind=real64), intent(in) :: b0p (:,:) real(kind=real64), intent(in) :: b1 (:,:) real(kind=real64), intent(in) :: b1p (:,:) real(kind=real64), intent(in) :: b2 (:,:) real(kind=real64), intent(in) :: b2p (:,:) real(kind=real64), intent(in) :: b3 (:,:) real(kind=real64), intent(in) :: b3p (:,:) real(kind=real64), intent(in) :: b3p2 (:,:) real(kind=real64), intent(in) :: b4 (:,:) real(kind=real64), intent(in) :: b4p (:,:) real(kind=real64), intent(in) :: dir (:,:) real(kind=real64), intent(in) :: ex (:,:) character(len=1), intent(in) :: np_str public  subroutine write_d_wavefunction (num) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num public  subroutine write_density_and_derivative (num) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num public  subroutine write_iter_Energy (iter) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter public  subroutine write_meanfield_Energy (iter) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter public  subroutine write_pot (num) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num public  subroutine write_prep_sort (iter) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter public  subroutine write_wavefunction (num) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num","tags":"","loc":"module/write_to_file.html"},{"title":"determine_observables – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Used by module~~determine_observables~~UsedByGraph module~determine_observables determine_observables proc~calc_observables main::calc_observables proc~calc_observables->module~determine_observables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions calc_PC2_ExV Subroutines calc_CM_Energy calc_Coulomb_Energy calc_Kinetic_Energy_by_integrate calc_Skyrme_Energy_by_integrate calc_Total_Energy Functions public  function calc_PC2_ExV (nuc_idx) result(expected_value) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nuc_idx Return Value real(kind=real64) Subroutines public  subroutine calc_CM_Energy () Arguments None public  subroutine calc_Coulomb_Energy () Arguments None public  subroutine calc_Kinetic_Energy_by_integrate () Arguments None public  subroutine calc_Skyrme_Energy_by_integrate () Arguments None public  subroutine calc_Total_Energy () Arguments None","tags":"","loc":"module/determine_observables.html"},{"title":"global_variables – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses iso_fortran_env constants_and_parameters module~~global_variables~~UsesGraph module~global_variables global_variables iso_fortran_env iso_fortran_env module~global_variables->iso_fortran_env module~constants_and_parameters constants_and_parameters module~global_variables->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~global_variables~~UsedByGraph module~global_variables global_variables proc~alloc_fields main::alloc_fields proc~alloc_fields->module~global_variables proc~calc_bpsi main::calc_Bpsi proc~calc_bpsi->module~global_variables proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_cm_energy->module~global_variables proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_coulomb_energy->module~global_variables proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_coulomb_pot->module~global_variables proc~calc_density_and_lap main::calc_density_and_lap proc~calc_density_and_lap->module~global_variables proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_derivation_of_wavefunction->module~global_variables proc~calc_ground_state main::calc_ground_state proc~calc_ground_state->module~global_variables proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_hf_by_imaginary_time_evolution->module~global_variables proc~calc_hpsi main::calc_Hpsi proc~calc_hpsi->module~global_variables proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hpsi2->module~global_variables proc~calc_imag_evolution main::calc_IMAG_Evolution proc~calc_imag_evolution->module~global_variables proc~calc_kinetic_density main::calc_kinetic_density proc~calc_kinetic_density->module~global_variables proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_kinetic_energy_by_integrate->module~global_variables proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_one_particle_energy->module~global_variables proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_pc2_exv->module~global_variables proc~calc_pot_b determine_meanfield_potential::calc_pot_B proc~calc_pot_b->module~global_variables proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u_np->module~global_variables proc~calc_pot_w determine_meanfield_potential::calc_pot_W proc~calc_pot_w->module~global_variables proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_skyrme_energy_by_integrate->module~global_variables proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_spin_orbit_density_and_div->module~global_variables proc~calc_total_energy determine_observables::calc_Total_Energy proc~calc_total_energy->module~global_variables proc~calc_upsi main::calc_Upsi proc~calc_upsi->module~global_variables proc~calc_woods_saxon determine_meanfield_potential::calc_Woods_Saxon proc~calc_woods_saxon->module~global_variables proc~calc_wpsi main::calc_Wpsi proc~calc_wpsi->module~global_variables proc~copy_to_occupied_wf main::copy_to_occupied_wf proc~copy_to_occupied_wf->module~global_variables proc~dealloc_fields main::dealloc_fields proc~dealloc_fields->module~global_variables proc~initial_settings main::initial_settings proc~initial_settings->module~global_variables proc~is_converge_for_one_e main::is_converge_for_one_E proc~is_converge_for_one_e->module~global_variables proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~nine_point_poisson_by_lapack->module~global_variables proc~overlap_to_file write_to_file::overlap_to_file proc~overlap_to_file->module~global_variables proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->module~global_variables proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->module~global_variables proc~prep_wf_overlap main::prep_wf_overlap proc~prep_wf_overlap->module~global_variables proc~read_input_parameters main::read_input_parameters proc~read_input_parameters->module~global_variables proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~schmidt_orthogonalization->module~global_variables proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~set_harmonic_occ->module~global_variables proc~sympson_volume_integrate math_integrate::sympson_volume_integrate proc~sympson_volume_integrate->module~global_variables proc~volume_integrate math_integrate::volume_integrate proc~volume_integrate->module~global_variables proc~write_d_wavefunction write_to_file::write_d_wavefunction proc~write_d_wavefunction->module~global_variables proc~write_density_and_derivative write_to_file::write_density_and_derivative proc~write_density_and_derivative->module~global_variables proc~write_iter_energy write_to_file::write_iter_Energy proc~write_iter_energy->module~global_variables proc~write_meanfield_energy write_to_file::write_meanfield_Energy proc~write_meanfield_energy->module~global_variables proc~write_pot write_to_file::write_pot proc~write_pot->module~global_variables proc~write_prep_sort write_to_file::write_prep_sort proc~write_prep_sort->module~global_variables proc~write_u_term write_to_file::write_U_term proc~write_u_term->module~global_variables proc~write_wavefunction write_to_file::write_wavefunction proc~write_wavefunction->module~global_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables Avarage_variance B_n B_p CM_Energy Coulomb_Energy Kinetic_Energy SDNWM SDNWP Skyrme_Energy Total_Energy U_n U_p W_n W_p b_0_term b_1_term b_2_term b_3_term b_4_term c_1_term ddr_rho_n ddr_rho_p ddr_wf_minus ddr_wf_plus ddz_rho_n ddz_rho_p ddz_wf_minus ddz_wf_plus direct_Coulomb_pot div_spin_orbit_dens_n div_spin_orbit_dens_p dr_rho_n dr_rho_p dr_wf_minus dr_wf_plus dz_rho_n dz_rho_p dz_wf_minus dz_wf_plus exchange_Coulomb_pot init_rzm_to_write kinetic_dens_n kinetic_dens_p lap_rho_n lap_rho_p lap_wf_minus lap_wf_plus magnetic_q_num prep_Bpsi_minus prep_Bpsi_plus prep_Hpsi2_minus prep_Hpsi2_plus prep_Hpsi_minus prep_Hpsi_plus prep_SDNWM prep_SDNWP prep_Upsi_minus prep_Upsi_plus prep_Wpsi_minus prep_Wpsi_plus prep_ddr_wf_minus prep_ddr_wf_plus prep_ddz_wf_minus prep_ddz_wf_plus prep_dr_wf_minus prep_dr_wf_plus prep_dz_wf_minus prep_dz_wf_plus prep_idx_array prep_lap_wf_minus prep_lap_wf_plus prep_magnetic_q_num prep_one_E_B prep_one_E_Kin prep_one_E_U prep_one_E_W prep_one_particle_E prep_one_particle_E2 prep_wf_minus prep_wf_plus r_vec rho_n rho_p spin_orbit_dens_n spin_orbit_dens_p thomas_fermi_n thomas_fermi_p wf_minus wf_plus z_vec Variables Type Visibility Attributes Name Initial real(kind=real64), public :: Avarage_variance real(kind=real64), public, allocatable :: B_n (:,:) real(kind=real64), public, allocatable :: B_p (:,:) real(kind=real64), public :: CM_Energy real(kind=real64), public :: Coulomb_Energy real(kind=real64), public :: Kinetic_Energy real(kind=real64), public, allocatable :: SDNWM (:,:,:) real(kind=real64), public, allocatable :: SDNWP (:,:,:) real(kind=real64), public :: Skyrme_Energy real(kind=real64), public :: Total_Energy real(kind=real64), public, allocatable :: U_n (:,:) real(kind=real64), public, allocatable :: U_p (:,:) real(kind=real64), public, allocatable :: W_n (:,:,:) real(kind=real64), public, allocatable :: W_p (:,:,:) real(kind=real64), public :: b_0_term real(kind=real64), public :: b_1_term real(kind=real64), public :: b_2_term real(kind=real64), public :: b_3_term real(kind=real64), public :: b_4_term real(kind=real64), public :: c_1_term real(kind=real64), public, allocatable :: ddr_rho_n (:,:) real(kind=real64), public, allocatable :: ddr_rho_p (:,:) real(kind=real64), public, allocatable :: ddr_wf_minus (:,:,:) real(kind=real64), public, allocatable :: ddr_wf_plus (:,:,:) real(kind=real64), public, allocatable :: ddz_rho_n (:,:) real(kind=real64), public, allocatable :: ddz_rho_p (:,:) real(kind=real64), public, allocatable :: ddz_wf_minus (:,:,:) real(kind=real64), public, allocatable :: ddz_wf_plus (:,:,:) real(kind=real64), public, allocatable :: direct_Coulomb_pot (:,:) real(kind=real64), public, allocatable :: div_spin_orbit_dens_n (:,:) real(kind=real64), public, allocatable :: div_spin_orbit_dens_p (:,:) real(kind=real64), public, allocatable :: dr_rho_n (:,:) real(kind=real64), public, allocatable :: dr_rho_p (:,:) real(kind=real64), public, allocatable :: dr_wf_minus (:,:,:) real(kind=real64), public, allocatable :: dr_wf_plus (:,:,:) real(kind=real64), public, allocatable :: dz_rho_n (:,:) real(kind=real64), public, allocatable :: dz_rho_p (:,:) real(kind=real64), public, allocatable :: dz_wf_minus (:,:,:) real(kind=real64), public, allocatable :: dz_wf_plus (:,:,:) real(kind=real64), public, allocatable :: exchange_Coulomb_pot (:,:) character(len=4), public, allocatable :: init_rzm_to_write (:) real(kind=real64), public, allocatable :: kinetic_dens_n (:,:) real(kind=real64), public, allocatable :: kinetic_dens_p (:,:) real(kind=real64), public, allocatable :: lap_rho_n (:,:) real(kind=real64), public, allocatable :: lap_rho_p (:,:) real(kind=real64), public, allocatable :: lap_wf_minus (:,:,:) real(kind=real64), public, allocatable :: lap_wf_plus (:,:,:) integer(kind=int32), public, allocatable :: magnetic_q_num (:) real(kind=real64), public, allocatable :: prep_Bpsi_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Bpsi_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Hpsi2_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Hpsi2_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Hpsi_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Hpsi_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_SDNWM (:,:,:,:) real(kind=real64), public, allocatable :: prep_SDNWP (:,:,:,:) real(kind=real64), public, allocatable :: prep_Upsi_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Upsi_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Wpsi_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_Wpsi_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_ddr_wf_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_ddr_wf_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_ddz_wf_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_ddz_wf_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_dr_wf_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_dr_wf_plus (:,:,:,:) real(kind=real64), public, allocatable :: prep_dz_wf_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_dz_wf_plus (:,:,:,:) integer(kind=int32), public, allocatable :: prep_idx_array (:,:) real(kind=real64), public, allocatable :: prep_lap_wf_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_lap_wf_plus (:,:,:,:) integer(kind=int32), public, allocatable :: prep_magnetic_q_num (:,:) real(kind=real64), public, allocatable :: prep_one_E_B (:,:,:) real(kind=real64), public, allocatable :: prep_one_E_Kin (:,:,:) real(kind=real64), public, allocatable :: prep_one_E_U (:,:,:) real(kind=real64), public, allocatable :: prep_one_E_W (:,:,:) real(kind=real64), public, allocatable :: prep_one_particle_E (:,:) real(kind=real64), public, allocatable :: prep_one_particle_E2 (:,:) real(kind=real64), public, allocatable :: prep_wf_minus (:,:,:,:) real(kind=real64), public, allocatable :: prep_wf_plus (:,:,:,:) real(kind=real64), public, allocatable :: r_vec (:) real(kind=real64), public, allocatable :: rho_n (:,:) real(kind=real64), public, allocatable :: rho_p (:,:) real(kind=real64), public, allocatable :: spin_orbit_dens_n (:,:,:) real(kind=real64), public, allocatable :: spin_orbit_dens_p (:,:,:) real(kind=real64), public, allocatable :: thomas_fermi_n (:,:) real(kind=real64), public, allocatable :: thomas_fermi_p (:,:) real(kind=real64), public, allocatable :: wf_minus (:,:,:) real(kind=real64), public, allocatable :: wf_plus (:,:,:) real(kind=real64), public, allocatable :: z_vec (:)","tags":"","loc":"module/global_variables.html"},{"title":"poisson_problem – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Used by module~~poisson_problem~~UsedByGraph module~poisson_problem poisson_problem proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_coulomb_pot->module~poisson_problem Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions get_k Subroutines nine_point_poisson_by_lapack three_point_poisson_by_lapack use_DGESV write_mat Functions public  function get_k (r_idx, z_idx) result(k_idx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: r_idx integer, intent(in) :: z_idx Return Value integer Subroutines public  subroutine nine_point_poisson_by_lapack (rho_p, coulomb) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho_p (:,:) real(kind=real64), intent(out) :: coulomb (:,:) public  subroutine three_point_poisson_by_lapack (rho_p, A, b) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho_p (:,:) real(kind=real64), intent(out) :: A (:,:) real(kind=real64), intent(out) :: b (:) public  subroutine use_DGESV (N, A, b, res_x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=8), intent(in) :: A (:,:) real(kind=8), intent(in) :: b (:) real(kind=8), intent(out) :: res_x (:) public  subroutine write_mat (A, N) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: A (:,:) integer, intent(in) :: N","tags":"","loc":"module/poisson_problem.html"},{"title":"harmonic_occ_wf – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses iso_fortran_env constants_and_parameters module~~harmonic_occ_wf~~UsesGraph module~harmonic_occ_wf harmonic_occ_wf iso_fortran_env iso_fortran_env module~harmonic_occ_wf->iso_fortran_env module~constants_and_parameters constants_and_parameters module~harmonic_occ_wf->module~constants_and_parameters module~constants_and_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~harmonic_occ_wf~~UsedByGraph module~harmonic_occ_wf harmonic_occ_wf proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~prep_initial_wavefunction->module~harmonic_occ_wf proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~prep_time_reversal_wavefunction->module~harmonic_occ_wf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables hboma xpi Functions calc_occ_energy set_harmonic_occ Variables Type Visibility Attributes Name Initial real(kind=real64), public :: hboma real(kind=real64), public :: xpi = sqrt(4.0d0/(5.0d0*pi)) Functions public  function calc_occ_energy (node_r, node_z, mag, betain) result(occ_energy) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: node_r integer(kind=int32), intent(in) :: node_z integer(kind=int32), intent(in) :: mag real(kind=real64), intent(in) :: betain Return Value real(kind=real64) public  function set_harmonic_occ (node_r, node_z, mag, r, z, betain) result(normilized_wf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: node_r integer(kind=int32), intent(in) :: node_z integer(kind=int32), intent(in) :: mag real(kind=real64), intent(in) :: r real(kind=real64), intent(in) :: z real(kind=real64), intent(in) :: betain Return Value real(kind=real64)","tags":"","loc":"module/harmonic_occ_wf.html"},{"title":"main – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Uses write_to_file ieee_arithmetic iso_fortran_env constants_and_parameters program~~main~~UsesGraph program~main main ieee_arithmetic ieee_arithmetic program~main->ieee_arithmetic iso_fortran_env iso_fortran_env program~main->iso_fortran_env module~constants_and_parameters constants_and_parameters program~main->module~constants_and_parameters module~write_to_file write_to_file program~main->module~write_to_file module~constants_and_parameters->iso_fortran_env module~write_to_file->iso_fortran_env module~write_to_file->module~constants_and_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~main~~CallsGraph program~main main proc~alloc_fields main::alloc_fields program~main->proc~alloc_fields proc~calc_ground_state main::calc_ground_state program~main->proc~calc_ground_state proc~dealloc_fields main::dealloc_fields program~main->proc~dealloc_fields proc~initial_settings main::initial_settings program~main->proc~initial_settings proc~outputsettings write_to_file::outputsettings program~main->proc~outputsettings proc~read_input_parameters main::read_input_parameters program~main->proc~read_input_parameters proc~calc_densities main::calc_densities proc~calc_ground_state->proc~calc_densities proc~calc_derivation_of_wavefunction main::calc_derivation_of_wavefunction proc~calc_ground_state->proc~calc_derivation_of_wavefunction proc~calc_hf_by_imaginary_time_evolution main::calc_hf_by_imaginary_time_evolution proc~calc_ground_state->proc~calc_hf_by_imaginary_time_evolution proc~calc_meanfield main::calc_meanfield proc~calc_ground_state->proc~calc_meanfield proc~calc_observables main::calc_observables proc~calc_ground_state->proc~calc_observables proc~copy_to_occupied_wf main::copy_to_occupied_wf proc~calc_ground_state->proc~copy_to_occupied_wf proc~write_d_wavefunction write_to_file::write_d_wavefunction proc~calc_ground_state->proc~write_d_wavefunction proc~write_density_and_derivative write_to_file::write_density_and_derivative proc~calc_ground_state->proc~write_density_and_derivative proc~write_iter_energy write_to_file::write_iter_Energy proc~calc_ground_state->proc~write_iter_energy proc~write_meanfield_energy write_to_file::write_meanfield_Energy proc~calc_ground_state->proc~write_meanfield_energy proc~write_pot write_to_file::write_pot proc~calc_ground_state->proc~write_pot proc~write_prep_sort write_to_file::write_prep_sort proc~calc_ground_state->proc~write_prep_sort proc~write_wavefunction write_to_file::write_wavefunction proc~calc_ground_state->proc~write_wavefunction proc~prep_initial_wavefunction main::prep_initial_wavefunction proc~initial_settings->proc~prep_initial_wavefunction proc~prep_time_reversal_wavefunction main::prep_time_reversal_wavefunction proc~initial_settings->proc~prep_time_reversal_wavefunction proc~make_one_file write_to_file::make_one_file proc~outputsettings->proc~make_one_file proc~calc_density_and_lap main::calc_density_and_lap proc~calc_densities->proc~calc_density_and_lap proc~calc_kinetic_density main::calc_kinetic_density proc~calc_densities->proc~calc_kinetic_density proc~calc_spin_orbit_density_and_div main::calc_spin_orbit_density_and_div proc~calc_densities->proc~calc_spin_orbit_density_and_div interface~math_diff_2r_9point math_derivation::math_diff_2r_9point proc~calc_derivation_of_wavefunction->interface~math_diff_2r_9point interface~math_diff_2z_9point math_derivation::math_diff_2z_9point proc~calc_derivation_of_wavefunction->interface~math_diff_2z_9point interface~math_diff_r_9point math_derivation::math_diff_r_9point proc~calc_derivation_of_wavefunction->interface~math_diff_r_9point interface~math_diff_z_9point math_derivation::math_diff_z_9point proc~calc_derivation_of_wavefunction->interface~math_diff_z_9point proc~calc_hpsi main::calc_Hpsi proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi proc~calc_hpsi2 main::calc_Hpsi2 proc~calc_hf_by_imaginary_time_evolution->proc~calc_hpsi2 proc~calc_imag_evolution main::calc_IMAG_Evolution proc~calc_hf_by_imaginary_time_evolution->proc~calc_imag_evolution proc~calc_one_particle_energy main::calc_one_particle_energy proc~calc_hf_by_imaginary_time_evolution->proc~calc_one_particle_energy proc~is_converge_for_one_e main::is_converge_for_one_E proc~calc_hf_by_imaginary_time_evolution->proc~is_converge_for_one_e proc~schmidt_orthogonalization main::Schmidt_orthogonalization proc~calc_hf_by_imaginary_time_evolution->proc~schmidt_orthogonalization proc~sort_energy_and_idx main::sort_energy_and_idx proc~calc_hf_by_imaginary_time_evolution->proc~sort_energy_and_idx proc~calc_pot_b determine_meanfield_potential::calc_pot_B proc~calc_meanfield->proc~calc_pot_b proc~calc_pot_u determine_meanfield_potential::calc_pot_U proc~calc_meanfield->proc~calc_pot_u proc~calc_pot_w determine_meanfield_potential::calc_pot_W proc~calc_meanfield->proc~calc_pot_w proc~calc_cm_energy determine_observables::calc_CM_Energy proc~calc_observables->proc~calc_cm_energy proc~calc_coulomb_energy determine_observables::calc_Coulomb_Energy proc~calc_observables->proc~calc_coulomb_energy proc~calc_kinetic_energy_by_integrate determine_observables::calc_Kinetic_Energy_by_integrate proc~calc_observables->proc~calc_kinetic_energy_by_integrate proc~calc_skyrme_energy_by_integrate determine_observables::calc_Skyrme_Energy_by_integrate proc~calc_observables->proc~calc_skyrme_energy_by_integrate proc~calc_total_energy determine_observables::calc_Total_Energy proc~calc_observables->proc~calc_total_energy proc~calc_occ_energy harmonic_occ_wf::calc_occ_energy proc~prep_initial_wavefunction->proc~calc_occ_energy proc~set_harmonic_occ harmonic_occ_wf::set_harmonic_occ proc~prep_initial_wavefunction->proc~set_harmonic_occ proc~prep_initial_wavefunction->proc~sort_energy_and_idx proc~prep_time_reversal_wavefunction->proc~calc_occ_energy proc~prep_time_reversal_wavefunction->proc~set_harmonic_occ proc~prep_time_reversal_wavefunction->proc~sort_energy_and_idx proc~math_diff_2r_9point_realfunc math_derivation::math_diff_2r_9point_realfunc interface~math_diff_2r_9point->proc~math_diff_2r_9point_realfunc proc~math_diff_2z_9point_realfunc math_derivation::math_diff_2z_9point_realfunc interface~math_diff_2z_9point->proc~math_diff_2z_9point_realfunc proc~math_diff_r_9point_complexfunc math_derivation::math_diff_r_9point_complexfunc interface~math_diff_r_9point->proc~math_diff_r_9point_complexfunc proc~math_diff_r_9point_realfunc math_derivation::math_diff_r_9point_realfunc interface~math_diff_r_9point->proc~math_diff_r_9point_realfunc proc~math_diff_z_9point_complexfunc math_derivation::math_diff_z_9point_complexfunc interface~math_diff_z_9point->proc~math_diff_z_9point_complexfunc proc~math_diff_z_9point_realfunc math_derivation::math_diff_z_9point_realfunc interface~math_diff_z_9point->proc~math_diff_z_9point_realfunc proc~calc_pc2_exv determine_observables::calc_PC2_ExV proc~calc_cm_energy->proc~calc_pc2_exv proc~volume_integrate math_integrate::volume_integrate proc~calc_coulomb_energy->proc~volume_integrate proc~calc_density_and_lap->interface~math_diff_2r_9point proc~calc_density_and_lap->interface~math_diff_2z_9point proc~calc_density_and_lap->interface~math_diff_r_9point proc~calc_density_and_lap->interface~math_diff_z_9point proc~calc_density_and_lap->proc~volume_integrate proc~calc_bpsi main::calc_Bpsi proc~calc_hpsi->proc~calc_bpsi proc~calc_upsi main::calc_Upsi proc~calc_hpsi->proc~calc_upsi proc~calc_wpsi main::calc_Wpsi proc~calc_hpsi->proc~calc_wpsi proc~calc_hpsi2->interface~math_diff_2r_9point proc~calc_hpsi2->interface~math_diff_2z_9point proc~calc_hpsi2->interface~math_diff_r_9point proc~calc_hpsi2->interface~math_diff_z_9point proc~calc_kinetic_energy_by_integrate->proc~volume_integrate proc~calc_one_particle_energy->proc~volume_integrate proc~calc_pot_u_np determine_meanfield_potential::calc_pot_U_np proc~calc_pot_u->proc~calc_pot_u_np proc~calc_skyrme_energy_by_integrate->proc~volume_integrate proc~calc_spin_orbit_density_and_div->interface~math_diff_r_9point proc~calc_spin_orbit_density_and_div->interface~math_diff_z_9point proc~prep_wf_overlap main::prep_wf_overlap proc~schmidt_orthogonalization->proc~prep_wf_overlap proc~hermite_n spacial_function::Hermite_n proc~set_harmonic_occ->proc~hermite_n proc~laguerre_nl spacial_function::Laguerre_nl proc~set_harmonic_occ->proc~laguerre_nl proc~calc_bpsi->interface~math_diff_r_9point proc~calc_bpsi->interface~math_diff_z_9point proc~calc_pc2_exv->proc~volume_integrate b0pt b0pt proc~calc_pot_u_np->b0pt b0t b0t proc~calc_pot_u_np->b0t b1pt b1pt proc~calc_pot_u_np->b1pt b1t b1t proc~calc_pot_u_np->b1t b2pt b2pt proc~calc_pot_u_np->b2pt b2t b2t proc~calc_pot_u_np->b2t b3pt b3pt proc~calc_pot_u_np->b3pt b3pt2 b3pt2 proc~calc_pot_u_np->b3pt2 b3t b3t proc~calc_pot_u_np->b3t b4pt b4pt proc~calc_pot_u_np->b4pt b4t b4t proc~calc_pot_u_np->b4t proc~calc_coulomb_pot determine_meanfield_potential::calc_coulomb_pot proc~calc_pot_u_np->proc~calc_coulomb_pot proc~write_u_term write_to_file::write_U_term proc~calc_pot_u_np->proc~write_u_term proc~prep_wf_overlap->proc~volume_integrate proc~nine_point_poisson_by_lapack poisson_problem::nine_point_poisson_by_lapack proc~calc_coulomb_pot->proc~nine_point_poisson_by_lapack proc~get_k poisson_problem::get_k proc~nine_point_poisson_by_lapack->proc~get_k proc~use_dgesv poisson_problem::use_DGESV proc~nine_point_poisson_by_lapack->proc~use_dgesv dgesv dgesv proc~use_dgesv->dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Variables num_iter str tf1 ti1 tr1 Functions prep_wf_overlap Subroutines Schmidt_orthogonalization alloc_fields calc_Bpsi calc_Hpsi calc_Hpsi2 calc_IMAG_Evolution calc_Upsi calc_Wpsi calc_densities calc_density_and_lap calc_derivation_of_wavefunction calc_ground_state calc_hf_by_imaginary_time_evolution calc_kinetic_density calc_meanfield calc_observables calc_one_particle_energy calc_spin_orbit_density_and_div copy_to_occupied_wf dealloc_fields initial_settings is_converge_for_one_E prep_initial_wavefunction prep_time_reversal_wavefunction read_input_parameters sort_energy_and_idx Variables Type Attributes Name Initial integer(kind=int32) :: num_iter character(len=40) :: str integer(kind=int32) :: tf1 integer(kind=int32) :: ti1 integer(kind=int32) :: tr1 Functions function prep_wf_overlap (idx_1, idx_2, np_int) result(ovlp) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: idx_1 integer(kind=int32), intent(in) :: idx_2 integer(kind=int32), intent(in) :: np_int Return Value real(kind=real64) Subroutines subroutine Schmidt_orthogonalization (np_int) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: np_int subroutine alloc_fields () Arguments None subroutine calc_Bpsi () Arguments None subroutine calc_Hpsi () Arguments None subroutine calc_Hpsi2 () Arguments None subroutine calc_IMAG_Evolution (np_int) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: np_int subroutine calc_Upsi () Arguments None subroutine calc_Wpsi () Arguments None subroutine calc_densities () Arguments None subroutine calc_density_and_lap () Arguments None subroutine calc_derivation_of_wavefunction () maxval(dble(prep_mag(prep,l)+1)/r_vec(i)*prep_wf_minus) Read more… Arguments None subroutine calc_ground_state () Arguments None subroutine calc_hf_by_imaginary_time_evolution () Arguments None subroutine calc_kinetic_density () Arguments None subroutine calc_meanfield () Arguments None subroutine calc_observables () Arguments None subroutine calc_one_particle_energy () Arguments None subroutine calc_spin_orbit_density_and_div () Arguments None subroutine copy_to_occupied_wf () Arguments None subroutine dealloc_fields () Arguments None subroutine initial_settings () Arguments None subroutine is_converge_for_one_E (is_converged) Arguments Type Intent Optional Attributes Name logical, intent(out) :: is_converged subroutine prep_initial_wavefunction () !!!!--------- prep_numberも変更してます -----------！！！！！！！！！！！ Arguments None subroutine prep_time_reversal_wavefunction () Arguments None subroutine read_input_parameters () Arguments None subroutine sort_energy_and_idx (energy_array, idx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: energy_array (:,:) integer(kind=int32), intent(inout) :: idx (:,:)","tags":"","loc":"program/main.html"},{"title":"determine_meanfield_potential.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~determine_meanfield_potential.f90~~EfferentGraph sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~constants_and_parameters.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~global_variables.f90 sourcefile~math_derivation.f90 math_derivation.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~math_derivation.f90 sourcefile~solve_poisson_problem.f90 solve_poisson_problem.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~solve_poisson_problem.f90 sourcefile~write_to_file.f90 write_to_file.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~write_to_file.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_derivation.f90->sourcefile~constants_and_parameters.f90 sourcefile~solve_poisson_problem.f90->sourcefile~constants_and_parameters.f90 sourcefile~solve_poisson_problem.f90->sourcefile~global_variables.f90 sourcefile~write_to_file.f90->sourcefile~constants_and_parameters.f90 sourcefile~write_to_file.f90->sourcefile~global_variables.f90 sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~write_to_file.f90->sourcefile~math_integrate.f90 sourcefile~math_integrate.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~global_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~determine_meanfield_potential.f90~~AfferentGraph sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules determine_meanfield_potential Source Code determine_meanfield_potential.f90 Source Code module determine_meanfield_potential use :: constants_and_parameters , only : is_coulomb implicit none contains subroutine calc_pot_U implicit none !call calc_Woods_Saxon ! pについてはクーロン項を付け足す必要がある call calc_pot_U_np ( \"n\" ,. false .) call calc_pot_U_np ( \"p\" , is_coulomb ) end subroutine calc_pot_U subroutine calc_Woods_Saxon use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: constants_and_parameters , only : Nr , Nz , z_center use :: global_variables , only : U_n , U_p , r_vec , z_vec implicit none real ( real64 ) :: r0 real ( real64 ) :: a real ( real64 ) :: VC real ( real64 ) :: radius integer ( int32 ) :: i , j r0 = 1.27d0 ! fm a = 0.67d0 ! fm VC = - 51 d0 !+ 33d0*(2d0-2d0)/4d0  ! MeV radius = r0 * ( 4 d0 ) ** ( 1 d0 / 3 d0 ) ! fm do j = 1 , Nz do i = 1 , Nr U_n ( i , j ) = VC / ( 1 d0 + exp (( sqrt ( r_vec ( i ) ** 2 + ( z_vec ( j ) - z_center ) ** 2 ) - radius ) / a )) U_p ( i , j ) = VC / ( 1 d0 + exp (( sqrt ( r_vec ( i ) ** 2 + ( z_vec ( j ) - z_center ) ** 2 ) - radius ) / a )) end do end do end subroutine calc_Woods_Saxon subroutine calc_pot_U_np ( np_str , is_coulomb ) use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: write_to_file , only : write_U_term use :: constants_and_parameters , only : e2 => elementary_charge2 , PI & , param_gamma , b_0 , b_0p , b_1 , b_1p , b_2 , b_2p , b_3 , b_3p , b_4 , b_4p , Nr , Nz & , is_update_coulomb , coulomb_updated_flag use :: global_variables , only : tau_n => kinetic_dens_n & , tau_p => kinetic_dens_p & , j_n => spin_orbit_dens_n & , j_p => spin_orbit_dens_p & , div_j_n => div_spin_orbit_dens_n & , div_j_p => div_spin_orbit_dens_p & , rho_n , rho_p , lap_rho_n , lap_rho_p & , U_n , U_p , direct_Coulomb_pot , exchange_Coulomb_pot implicit none character ( 1 ), intent ( in ) :: np_str logical , intent ( in ), optional :: is_coulomb real ( real64 ), allocatable :: U_np (:,:) ! [MeV] (r,z) real ( real64 ), allocatable :: rho_np (:,:) ! [fm&#94;-3] (r,z) real ( real64 ), allocatable :: tau_np (:,:) ! [fm&#94;-3] (r,z) real ( real64 ), allocatable :: j_np (:,:,:) ! [fm&#94;-3] (r,z,component) real ( real64 ), allocatable :: laplacian_rho_np (:,:) ! [fm&#94;-5] (r,z) real ( real64 ), allocatable :: div_j_np (:,:) ! [fm&#94;-4] (r,z,component) real ( real64 ), allocatable :: rho (:,:) ! [fm&#94;-3] (r,z) real ( real64 ), allocatable :: tau (:,:) ! [fm&#94;-3] (r,z) real ( real64 ), allocatable :: laplacian_rho (:,:) ! [fm&#94;-5] (r,z) real ( real64 ), allocatable :: div_j (:,:) ! [fm&#94;-4] (r,z,component) if ( np_str /= \"n\" . and . np_str /= \"p\" ) then write ( * , * ) \"Error: np_str must be 'n' or 'p'.\" stop end if allocate ( U_np ( Nr , Nz )) allocate ( rho_np ( Nr , Nz )) allocate ( tau_np ( Nr , Nz )) allocate ( j_np ( Nr , Nz , 3 )) allocate ( laplacian_rho_np ( Nr , Nz )) allocate ( div_j_np ( Nr , Nz )) allocate ( rho ( Nr , Nz )) allocate ( tau ( Nr , Nz )) allocate ( laplacian_rho ( Nr , Nz )) allocate ( div_j ( Nr , Nz )) if ( np_str == \"n\" ) then rho_np (:,:) = rho_n (:,:) tau_np (:,:) = tau_n (:,:) j_np (:,:,:) = j_n (:,:,:) laplacian_rho_np (:,:) = lap_rho_n (:,:) div_j_np (:,:) = div_j_n (:,:) else if ( np_str == \"p\" ) then rho_np (:,:) = rho_p (:,:) tau_np (:,:) = tau_p (:,:) j_np (:,:,:) = j_p (:,:,:) laplacian_rho_np (:,:) = lap_rho_p (:,:) div_j_np (:,:) = div_j_p (:,:) end if laplacian_rho (:,:) = lap_rho_n (:,:) + lap_rho_p (:,:) rho (:,:) = rho_n (:,:) + rho_p (:,:) tau (:,:) = tau_n (:,:) + tau_p (:,:) div_j (:,:) = div_j_n (:,:) + div_j_p (:,:) U_np (:,:) = b_0 * rho (:,:) - b_0p * rho_np (:,:) & + b_1 * tau (:,:) - b_1p * tau_np (:,:) & - b_2 * laplacian_rho (:,:) + b_2p * laplacian_rho_np (:,:) & + b_3 * ( param_gamma + 2 d0 ) / 3 d0 * rho (:,:) ** ( param_gamma + 1 d0 ) & - b_3p * 2 d0 / 3 d0 * rho (:,:) ** ( param_gamma ) * rho_np (:,:) & - b_3p * param_gamma / 3 d0 * rho (:,:) ** ( param_gamma - 1 d0 ) * ( rho_n (:,:) ** 2 + rho_p (:,:) ** 2 ) & - b_4 * div_j (:,:) - b_4p * div_j_np (:,:) ! 9bのdelta_{qp}の前までの式を計算している。 if ( np_str == \"n\" ) then U_n (:,:) = U_np (:,:) else if ( np_str == \"p\" ) then ! クーロンポテンシャルを追加する必要あり if ( is_coulomb ) then if ( is_update_coulomb ) then call calc_coulomb_pot ! update direct_Coulomb_pot is_update_coulomb = . false . coulomb_updated_flag = . true . end if exchange_Coulomb_pot (:,:) = e2 * ( 3 d0 / PI ) ** ( 1 d0 / 3 d0 ) * rho_p (:,:) ** ( 1 d0 / 3 d0 ) ! direct_Coulomb_pot   = e**2 * \\int dV' rho(r')/|r-r'| ! exchange_Coulomb_pot = e**2 * (3/PI)**(1/3) * rho_p(r')**(1/3) end if U_p (:,:) = U_np (:,:) + direct_Coulomb_pot (:,:) - exchange_Coulomb_pot (:,:) end if block real ( real64 ), allocatable :: b0t (:,:), b0pt (:,:), b1t (:,:), b1pt (:,:), b2t (:,:), b2pt (:,:)& , b3t (:,:), b3pt (:,:), b3pt2 (:,:), b4t (:,:), b4pt (:,:) allocate ( b0t ( Nr , Nz )) allocate ( b0pt ( Nr , Nz )) allocate ( b1t ( Nr , Nz )) allocate ( b1pt ( Nr , Nz )) allocate ( b2t ( Nr , Nz )) allocate ( b2pt ( Nr , Nz )) allocate ( b3t ( Nr , Nz )) allocate ( b3pt ( Nr , Nz )) allocate ( b3pt2 ( Nr , Nz )) allocate ( b4t ( Nr , Nz )) allocate ( b4pt ( Nr , Nz )) b0t (:,:) = b_0 * rho (:,:) b0pt (:,:) = b_0p * rho_np (:,:) b1t (:,:) = b_1 * tau (:,:) b1pt (:,:) = b_1p * tau_np (:,:) b2t (:,:) = b_2 * laplacian_rho (:,:) b2pt (:,:) = b_2p * laplacian_rho_np (:,:) b3t (:,:) = b_3 * ( param_gamma + 2 d0 ) / 3 d0 * rho (:,:) ** ( param_gamma + 1 d0 ) b3pt (:,:) = b_3p * 2 d0 / 3 d0 * rho (:,:) ** ( param_gamma ) * rho_np (:,:) b3pt2 (:,:) = b_3p * param_gamma / 3 d0 * rho (:,:) ** ( param_gamma - 1 d0 ) * ( rho_n (:,:) ** 2 + rho_p (:,:) ** 2 ) b4t (:,:) = b_4 * div_j (:,:) b4pt (:,:) = b_4p * div_j_np (:,:) call write_U_term ( b0t (:,:), b0pt (:,:), b1t (:,:), b1pt (:,:), b2t (:,:)& , b2pt (:,:), b3t (:,:), b3pt (:,:), b3pt2 (:,:), b4t (:,:), b4pt (:,:)& , direct_Coulomb_pot (:,:), exchange_Coulomb_pot (:,:), np_str ) deallocate ( b0t , b0pt , b1t , b1pt , b2t , b2pt , b3t , b3pt , b3pt2 , b4t , b4pt ) end block deallocate ( U_np ) deallocate ( rho_np ) deallocate ( tau_np ) deallocate ( j_np ) deallocate ( laplacian_rho_np ) deallocate ( div_j_np ) deallocate ( rho ) deallocate ( tau ) deallocate ( laplacian_rho ) deallocate ( div_j ) end subroutine calc_pot_U_np subroutine calc_coulomb_pot ! 後でモーメントの足し算に変更するかも．今はlapackで解いている use , intrinsic :: iso_fortran_env , only : int32 use global_variables , only : rho_p , direct_Coulomb_pot use poisson_problem , only : nine_point_poisson_by_lapack implicit none ! 時間計測を行う !integer(int32) :: ti,tf,tr !call system_clock(ti) call nine_point_poisson_by_lapack ( rho_p (:,:), direct_Coulomb_pot (:,:)) !call system_clock(tf,tr) !write(6,'(f10.3,A)')(tf-ti)/dble(tr),'[s]' end subroutine calc_coulomb_pot subroutine calc_pot_B use :: constants_and_parameters , only : HBAR2_over_2m , b_1 , b_1p use :: global_variables , only : rho_n , rho_p , B_n , B_p implicit none B_n (:,:) = b_1 * ( rho_n (:,:) + rho_p (:,:)) - b_1p * rho_n (:,:) B_p (:,:) = b_1 * ( rho_n (:,:) + rho_p (:,:)) - b_1p * rho_p (:,:) end subroutine calc_pot_B subroutine calc_pot_W use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: constants_and_parameters , only : Nr , Nz , b_4 , b_4p , c_1 , c_1p use :: global_variables , only : j_n => spin_orbit_dens_n , j_p => spin_orbit_dens_p & , rho_n , rho_p , dr_rho_n , dr_rho_p , dz_rho_n , dz_rho_p & , W_n , W_p use :: math_derivation , only : math_diff_r_9point , math_diff_z_9point implicit none real ( real64 ), allocatable :: rho (:,:) ! [fm&#94;-3] (r,z) real ( real64 ), allocatable :: spin_orbit_dens (:,:,:) ! [fm&#94;-3] (r,z,component) real ( real64 ), allocatable :: dr_rho (:,:) real ( real64 ), allocatable :: dz_rho (:,:) integer ( int32 ) :: i , j allocate ( rho ( Nr , Nz )) allocate ( spin_orbit_dens ( Nr , Nz , 3 )) allocate ( dr_rho , mold = rho_n ) allocate ( dz_rho , mold = rho_n ) rho (:,:) = rho_n (:,:) + rho_p (:,:) spin_orbit_dens (:,:,:) = j_n (:,:,:) + j_p (:,:,:) dr_rho (:,:) = dr_rho_n (:,:) + dr_rho_p (:,:) dz_rho (:,:) = dz_rho_n (:,:) + dz_rho_p (:,:) do j = 1 , Nz do i = 1 , Nr W_n ( i , j , 1 ) = b_4 * dr_rho ( i , j ) + b_4p * dr_rho_n ( i , j ) & - 2 d0 * c_1 * spin_orbit_dens ( i , j , 1 ) + 2 d0 * c_1p * j_n ( i , j , 1 ) W_n ( i , j , 2 ) = 0 d0 W_n ( i , j , 3 ) = b_4 * dz_rho ( i , j ) + b_4p * dz_rho_n ( i , j ) & - 2 d0 * c_1 * spin_orbit_dens ( i , j , 3 ) + 2 d0 * c_1p * j_n ( i , j , 3 ) W_p ( i , j , 1 ) = b_4 * dr_rho ( i , j ) + b_4p * dr_rho_p ( i , j ) & - 2 d0 * c_1 * spin_orbit_dens ( i , j , 1 ) + 2 d0 * c_1p * j_p ( i , j , 1 ) W_p ( i , j , 2 ) = 0 d0 W_p ( i , j , 3 ) = b_4 * dz_rho ( i , j ) + b_4p * dz_rho_p ( i , j ) & - 2 d0 * c_1 * spin_orbit_dens ( i , j , 3 ) + 2 d0 * c_1p * j_p ( i , j , 3 ) end do end do end subroutine calc_pot_W end module determine_meanfield_potential","tags":"","loc":"sourcefile/determine_meanfield_potential.f90.html"},{"title":"math_derivation.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~math_derivation.f90~~EfferentGraph sourcefile~math_derivation.f90 math_derivation.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~math_derivation.f90->sourcefile~constants_and_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~math_derivation.f90~~AfferentGraph sourcefile~math_derivation.f90 math_derivation.f90 sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~math_derivation.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~math_derivation.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules math_derivation Source Code math_derivation.f90 Source Code module math_derivation use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none real ( real64 ) :: eps = 0.03d0 interface math_diff_r_9point module procedure math_diff_r_9point_realfunc , math_diff_r_9point_complexfunc end interface math_diff_r_9point interface math_diff_z_9point module procedure math_diff_z_9point_realfunc , math_diff_z_9point_complexfunc end interface math_diff_z_9point interface math_diff_2r_9point module procedure math_diff_2r_9point_realfunc end interface math_diff_2r_9point interface math_diff_2z_9point module procedure math_diff_2z_9point_realfunc end interface math_diff_2z_9point contains ! r方向の微分はr=0で偶関数であることを利用している ! z方向の微分とr遠方は関数値がゼロになることを利用している function math_diff_2r_9point_realfunc ( f ) result ( f_2r ) use constants_and_parameters , only : dr , z_center implicit none real ( real64 ), intent ( in ) :: f (:,:) real ( real64 ), allocatable :: f_2r (:,:) real ( real64 ) :: weight ( - 4 : 4 ) = [ - 9 d0 , 128 d0 , - 1008 d0 , 8064 d0 , - 14350 d0 , 8064 d0 , - 1008 d0 , 128 d0 , - 9 d0 ] real ( real64 ) :: f_tmp ( - 4 : 4 ) = 0 d0 integer ( int32 ) :: i , j , k integer ( int32 ) :: Nr , Nz allocate ( f_2r , mold = f ) f_2r (:,:) = 0 d0 Nr = size ( f , 1 ) Nz = size ( f , 2 ) do i = 1 , Nr do j = 1 , Nz do k =- 4 , - 1 ! 負の方向について if ( i + k < 1 ) then ! f(0) -> f(1), f(-1) -> f(2),... if ( abs ( f ( 1 , int ( z_center / dr ))) < eps ) then f_tmp ( k ) = - f ( - k + 1 - i , j ) else f_tmp ( k ) = f ( - k + 1 - i , j ) end if else f_tmp ( k ) = f ( i + k , j ) end if f_2r ( i , j ) = f_2r ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_2r ( i , j ) = f_2r ( i , j ) + weight ( 0 ) * f ( i , j ) do k = 1 , 4 ! 正の方向について if ( i + k > Nr ) then f_tmp ( k ) = 0 d0 ! 境界の外側はゼロになる else f_tmp ( k ) = f ( i + k , j ) end if f_2r ( i , j ) = f_2r ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_2r ( i , j ) = f_2r ( i , j ) / ( 5040 d0 * dr * dr ) end do end do end function math_diff_2r_9point_realfunc function math_diff_2z_9point_realfunc ( f ) result ( f_2z ) use constants_and_parameters , only : dz implicit none real ( real64 ), intent ( in ) :: f (:,:) real ( real64 ), allocatable :: f_2z (:,:) real ( real64 ) :: weight ( - 4 : 4 ) = [ - 9 d0 , 128 d0 , - 1008 d0 , 8064 d0 , - 14350 d0 , 8064 d0 , - 1008 d0 , 128 d0 , - 9 d0 ] real ( real64 ) :: f_tmp ( - 4 : 4 ) = 0 d0 integer ( int32 ) :: i , j , k integer ( int32 ) :: Nr , Nz allocate ( f_2z , mold = f ) f_2z (:,:) = 0 d0 Nr = size ( f , 1 ) Nz = size ( f , 2 ) do i = 1 , Nr do j = 1 , Nz do k =- 4 , - 1 if ( j + k < 1 ) then f_tmp ( k ) = 0 d0 else f_tmp ( k ) = f ( i , j + k ) end if f_2z ( i , j ) = f_2z ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_2z ( i , j ) = f_2z ( i , j ) + weight ( 0 ) * f ( i , j ) do k = 1 , 4 if ( j + k > Nz ) then f_tmp ( k ) = 0 d0 else f_tmp ( k ) = f ( i , j + k ) end if f_2z ( i , j ) = f_2z ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_2z ( i , j ) = f_2z ( i , j ) / ( 5040 d0 * dz * dz ) end do end do end function math_diff_2z_9point_realfunc function math_diff_r_9point_realfunc ( f ) result ( f_r ) use constants_and_parameters , only : dr , z_center implicit none real ( real64 ), intent ( in ) :: f (:,:) real ( real64 ), allocatable :: f_r (:,:) real ( real64 ) :: weight ( - 4 : 4 ) = [ 3 d0 , - 32 d0 , 168 d0 , - 672 d0 , 0 d0 , 672 d0 , - 168 d0 , 32 d0 , - 3 d0 ] real ( real64 ) :: f_tmp ( - 4 : 4 ) = 0 d0 integer ( int32 ) :: i , j , k integer ( int32 ) :: Nr , Nz allocate ( f_r , mold = f ) f_r (:,:) = 0 d0 Nr = size ( f , 1 ) Nz = size ( f , 2 ) do i = 1 , Nr do j = 1 , Nz do k =- 4 , - 1 if ( i + k < 1 ) then ! f(-1)を参照するならf(1)を参照する if ( abs ( f ( 1 , int ( z_center / dr ))) < eps ) then f_tmp ( k ) = - f ( - k + 1 - i , j ) else f_tmp ( k ) = f ( - k + 1 - i , j ) end if else f_tmp ( k ) = f ( i + k , j ) end if f_r ( i , j ) = f_r ( i , j ) + weight ( k ) * f_tmp ( k ) end do do k = 1 , 4 if ( i + k > Nr ) then f_tmp ( k ) = 0 d0 else f_tmp ( k ) = f ( i + k , j ) end if f_r ( i , j ) = f_r ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_r ( i , j ) = f_r ( i , j ) / ( 840 d0 * dr ) end do end do end function math_diff_r_9point_realfunc function math_diff_r_9point_complexfunc ( f ) result ( f_r ) use constants_and_parameters , only : dr implicit none complex ( real64 ), intent ( in ) :: f (:,:) complex ( real64 ), allocatable :: f_r (:,:) real ( real64 ) :: weight ( - 4 : 4 ) = [ 3 d0 , - 32 d0 , 168 d0 , - 672 d0 , 0 d0 , 672 d0 , - 168 d0 , 32 d0 , - 3 d0 ] complex ( real64 ) :: f_tmp ( - 4 : 4 ) = 0 d0 integer ( int32 ) :: i , j , k integer ( int32 ) :: Nr , Nz allocate ( f_r , mold = f ) f_r (:,:) = 0 d0 Nr = size ( f , 1 ) Nz = size ( f , 2 ) do i = 1 , Nr do j = 1 , Nz do k =- 4 , - 1 if ( i + k < 1 ) then f_tmp ( k ) = f ( - k + 1 - i , j ) else f_tmp ( k ) = f ( i + k , j ) end if f_r ( i , j ) = f_r ( i , j ) + weight ( k ) * f_tmp ( k ) end do do k = 1 , 4 if ( i + k > Nr ) then f_tmp ( k ) = 0 d0 else f_tmp ( k ) = f ( i + k , j ) end if f_r ( i , j ) = f_r ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_r ( i , j ) = f_r ( i , j ) / ( 840 d0 * dr ) end do end do end function math_diff_r_9point_complexfunc function math_diff_z_9point_realfunc ( f ) result ( f_z ) use constants_and_parameters , only : dz implicit none real ( real64 ), intent ( in ) :: f (:,:) real ( real64 ), allocatable :: f_z (:,:) real ( real64 ) :: weight ( - 4 : 4 ) = [ 3 d0 , - 32 d0 , 168 d0 , - 672 d0 , 0 d0 , 672 d0 , - 168 d0 , 32 d0 , - 3 d0 ] real ( real64 ) :: f_tmp ( - 4 : 4 ) = 0 d0 integer ( int32 ) :: i , j , k integer ( int32 ) :: Nr , Nz allocate ( f_z , mold = f ) f_z (:,:) = 0 d0 Nr = size ( f , 1 ) Nz = size ( f , 2 ) do i = 1 , Nr do j = 1 , Nz do k =- 4 , - 1 if ( j + k < 1 ) then f_tmp ( k ) = f ( i , - k + 1 - j ) else f_tmp ( k ) = f ( i , j + k ) end if f_z ( i , j ) = f_z ( i , j ) + weight ( k ) * f_tmp ( k ) end do do k = 1 , 4 if ( j + k > Nz ) then f_tmp ( k ) = 0 d0 else f_tmp ( k ) = f ( i , j + k ) end if f_z ( i , j ) = f_z ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_z ( i , j ) = f_z ( i , j ) / ( 840 d0 * dz ) end do end do end function math_diff_z_9point_realfunc function math_diff_z_9point_complexfunc ( f ) result ( f_z ) use constants_and_parameters , only : dz implicit none complex ( real64 ), intent ( in ) :: f (:,:) complex ( real64 ), allocatable :: f_z (:,:) real ( real64 ) :: weight ( - 4 : 4 ) = [ 3 d0 , - 32 d0 , 168 d0 , - 672 d0 , 0 d0 , 672 d0 , - 168 d0 , 32 d0 , - 3 d0 ] complex ( real64 ) :: f_tmp ( - 4 : 4 ) = 0 d0 integer ( int32 ) :: i , j , k integer ( int32 ) :: Nr , Nz allocate ( f_z , mold = f ) f_z (:,:) = 0 d0 Nr = size ( f , 1 ) Nz = size ( f , 2 ) do i = 1 , Nr do j = 1 , Nz do k =- 4 , - 1 if ( j + k < 1 ) then f_tmp ( k ) = f ( i , - k + 1 - j ) else f_tmp ( k ) = f ( i , j + k ) end if f_z ( i , j ) = f_z ( i , j ) + weight ( k ) * f_tmp ( k ) end do do k = 1 , 4 if ( j + k > Nz ) then f_tmp ( k ) = 0 d0 else f_tmp ( k ) = f ( i , j + k ) end if f_z ( i , j ) = f_z ( i , j ) + weight ( k ) * f_tmp ( k ) end do f_z ( i , j ) = f_z ( i , j ) / ( 840 d0 * dz ) end do end do end function math_diff_z_9point_complexfunc end module math_derivation","tags":"","loc":"sourcefile/math_derivation.f90.html"},{"title":"spacial_function.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Files dependent on this one sourcefile~~spacial_function.f90~~AfferentGraph sourcefile~spacial_function.f90 spacial_function.f90 sourcefile~harmonic_occ.f90 harmonic_occ.f90 sourcefile~harmonic_occ.f90->sourcefile~spacial_function.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~harmonic_occ.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules spacial_function Source Code spacial_function.f90 Source Code module spacial_function use , intrinsic :: iso_fortran_env implicit none contains function Laguerre_nl ( n , l , x ) result ( res ) implicit none real ( real64 ) :: res , tes integer ( int32 ), intent ( in ) :: n , l real ( real64 ), intent ( in ) :: x integer ( int32 ) :: i res = 0 d0 do i = 0 , n res = res + ( - x ) ** i / ( gamma ( dble ( i + l + 1 )) * gamma ( dble ( n - i + 1 )) * gamma ( dble ( i + 1 ))) end do tes = ( gamma ( dble ( n + l + 1 ))) res = res * ( gamma ( dble ( n + l + 1 ))) ! 足立先生のプリントとは違う定義 end function Laguerre_nl function Hermite_n ( n , x ) result ( res ) implicit none real ( real64 ) :: res integer ( int32 ), intent ( in ) :: n real ( real64 ), intent ( in ) :: x integer ( int32 ) :: i res = 0 d0 do i = 0 , floor ( dble ( n ) / 2 d0 ) res = res + ( - 1 ) ** i * gamma ( dble ( n + 1 )) / ( gamma ( dble ( i + 1 )) * gamma ( dble ( n - 2 * i + 1 ))) * ( 2 d0 * x ) ** ( n - 2 * i ) end do end function Hermite_n end module spacial_function","tags":"","loc":"sourcefile/spacial_function.f90.html"},{"title":"constants_and_parameters.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"Files dependent on this one sourcefile~~constants_and_parameters.f90~~AfferentGraph sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~constants_and_parameters.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~global_variables.f90 sourcefile~math_derivation.f90 math_derivation.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~math_derivation.f90 sourcefile~solve_poisson_problem.f90 solve_poisson_problem.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~solve_poisson_problem.f90 sourcefile~write_to_file.f90 write_to_file.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~write_to_file.f90 sourcefile~determine_observables.f90 determine_observables.f90 sourcefile~determine_observables.f90->sourcefile~constants_and_parameters.f90 sourcefile~determine_observables.f90->sourcefile~global_variables.f90 sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~determine_observables.f90->sourcefile~math_integrate.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 sourcefile~harmonic_occ.f90 harmonic_occ.f90 sourcefile~harmonic_occ.f90->sourcefile~constants_and_parameters.f90 sourcefile~harmonic_occ.f90->sourcefile~global_variables.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~constants_and_parameters.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 sourcefile~main.f90->sourcefile~determine_observables.f90 sourcefile~main.f90->sourcefile~global_variables.f90 sourcefile~main.f90->sourcefile~harmonic_occ.f90 sourcefile~main.f90->sourcefile~math_derivation.f90 sourcefile~main.f90->sourcefile~math_integrate.f90 sourcefile~main.f90->sourcefile~write_to_file.f90 sourcefile~math_derivation.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~global_variables.f90 sourcefile~solve_poisson_problem.f90->sourcefile~constants_and_parameters.f90 sourcefile~solve_poisson_problem.f90->sourcefile~global_variables.f90 sourcefile~write_to_file.f90->sourcefile~constants_and_parameters.f90 sourcefile~write_to_file.f90->sourcefile~global_variables.f90 sourcefile~write_to_file.f90->sourcefile~math_integrate.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules constants_and_parameters Source Code constants_and_parameters.f90 Source Code module constants_and_parameters use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none !-- math and physical constants -- real ( real64 ), parameter :: PI = 4.0d0 * atan ( 1.0d0 ) real ( real64 ), parameter :: HBARC = 19 7.32705d0 ! [MeV.fm] real ( real64 ), parameter :: mass_of_proton = 93 8.272088d0 ! [MeV] real ( real64 ), parameter :: mass_of_neutron = 93 9.565413d0 ! [MeV] real ( real64 ), parameter :: fine_structure = 1 d0 / 13 7.04d0 ! Fine Structure Constant real ( real64 ), parameter :: elementary_charge2 = HBARC * fine_structure ! [MeV.fm] real ( real64 ), parameter :: HBAR2_over_2m = 2 0.75250d0 ! [MeV.fm&#94;2] complex ( real64 ), parameter :: imaginary_unit = ( 0.0d0 , 1.0d0 ) !-- Parameters of Skyrme force -- real ( real64 ), parameter :: t_0 = - 264 5.0d0 real ( real64 ), parameter :: t_1 = 41 0.0d0 real ( real64 ), parameter :: t_2 = - 13 5.0d0 real ( real64 ), parameter :: t_3 = 1559 5.0d0 real ( real64 ), parameter :: t_4 = 13 0.0d0 real ( real64 ), parameter :: x_0 = 0.090d0 real ( real64 ), parameter :: x_1 = 0.0d0 real ( real64 ), parameter :: x_2 = 0.0d0 real ( real64 ), parameter :: x_3 = 0.0d0 real ( real64 ), parameter :: param_gamma = 1.0d0 / 6.0d0 real ( real64 ), parameter :: b_0 = t_0 * ( 1 d0 + x_0 / 2 d0 ) real ( real64 ), parameter :: b_0p = t_0 * ( 1 d0 / 2 d0 + x_0 ) real ( real64 ), parameter :: b_1 = 1 d0 / 4 d0 * ( t_1 * ( 1 d0 + x_1 / 2 d0 ) + t_2 * ( 1 d0 + x_2 / 2 d0 )) real ( real64 ), parameter :: b_1p = 1 d0 / 4 d0 * ( t_1 * ( 1 d0 / 2 d0 + x_1 ) - t_2 * ( 1 d0 / 2 d0 + x_2 )) real ( real64 ), parameter :: b_2 = 1 d0 / 8 d0 * ( 3 d0 * t_1 * ( 1 d0 + x_1 / 2 d0 ) - t_2 * ( 1 d0 + x_2 / 2 d0 )) real ( real64 ), parameter :: b_2p = 1 d0 / 8 d0 * ( 3 d0 * t_1 * ( 1 d0 / 2 d0 + x_1 ) + t_2 * ( 1 d0 / 2 d0 + x_2 )) real ( real64 ), parameter :: b_3 = 1 d0 / 4 d0 * t_3 * ( 1 d0 + x_3 / 2 d0 ) real ( real64 ), parameter :: b_3p = 1 d0 / 4 d0 * t_3 * ( 1 d0 / 2 d0 + x_3 ) real ( real64 ), parameter :: b_4 = t_4 / 2 d0 real ( real64 ), parameter :: b_4p = t_4 / 2 d0 real ( real64 ), parameter :: eta = 1 d0 real ( real64 ), parameter :: c_1 = eta * 1 d0 / 16 d0 * ( t_1 * x_1 + t_2 * x_2 ) real ( real64 ), parameter :: c_1p = eta * 1 d0 / 16 d0 * ( t_1 - t_2 ) !-- Numerical parameters (can override by inputfile) -- integer ( int32 ) :: Nr = 100 ! The number of grid points in r-direction (r&#94;2=x&#94;2+y&#94;2) integer ( int32 ) :: Nz = 100 ! The number of grid points in z-direction integer ( int32 ) :: num_p = 2 ! The number of protons integer ( int32 ) :: num_n = 2 ! The number of neutrons real ( real64 ) , parameter :: r_max = 20 d0 ! [fm] The maximum value of r (0<=r<=r_max) real ( real64 ) , parameter :: z_max = 20 d0 ! [fm] The maximum value of z (-z_max<=z<=z_max) real ( real64 ) , parameter :: deformation_degree = 0.0d0 ! deformation degree of nucleus ! 0.1 がのーまる integer ( int32 ) :: prep_max_m = 3 ! 方位量子数の最大値 integer ( int32 ) :: prep_max_r = 3 ! 主量子数の最大値 integer ( int32 ) :: prep_max_z = 3 ! z成分の最大値 integer ( int32 ) :: prep_number = 2 ! 用意する軌道の数 real ( real64 ) :: dr ! [fm] The grid spacing in r-direction real ( real64 ) :: dz ! [fm] The grid spacing in z-direction real ( real64 ) :: z_center = z_max / 2 d0 ! [fm] The center of z-direction character ( len = 8 ) :: str_z ! center of z-direction real ( real64 ) :: imaginary_time_step = 1 d - 2 ! imaginary time step E=50MeVとしてE*ct/hbarc <1になるように設定 real ( real64 ) :: cou_eps = 1 d0 ! coulobm interactionを考慮するしきい値 real ( real64 ) :: SD_eps = 1 d - 6 real ( real64 ) :: prev_eps = 1 d - 12 ! 計算の収束判定に用いる値 real ( real64 ) :: lagrange_multiplier = 1 d0 ! ラグランジュの未定乗数法におけるラグランジュ乗数 character ( len = 8 ) :: nuc_name integer ( int32 ) :: max_iter = 5000 ! 最大反復回数 integer ( int32 ) :: plot_iter = 500 logical :: is_output = . true . logical :: is_use_dd = . true . logical :: not_divJ = . true . logical :: is_use_B = . true . logical :: is_use_W = . true . logical :: is_TimeR = . true . logical :: is_converged = . false . logical :: is_minus_var = . false . logical :: is_coulomb = . false . logical :: is_update_coulomb = . true . ! 最初にクーロンを計算する logical :: coulomb_updated_flag = . false . ! クーロンを更新したかどうかのフラグ logical :: is_use_second_imag = . false . !-- use output file(for python) -- character ( len = 8 ) :: date character ( len = 10 ) :: time character ( len = 12 ) :: MMDDHHMMSS character ( len = 9 ), parameter :: resultdir = \"./../res/\" ! outputdir character ( len = 21 ) :: foldername end module constants_and_parameters","tags":"","loc":"sourcefile/constants_and_parameters.f90.html"},{"title":"math_integrate.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~math_integrate.f90~~EfferentGraph sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~constants_and_parameters.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~math_integrate.f90->sourcefile~global_variables.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~math_integrate.f90~~AfferentGraph sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~determine_observables.f90 determine_observables.f90 sourcefile~determine_observables.f90->sourcefile~math_integrate.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~math_integrate.f90 sourcefile~main.f90->sourcefile~determine_observables.f90 sourcefile~write_to_file.f90 write_to_file.f90 sourcefile~main.f90->sourcefile~write_to_file.f90 sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 sourcefile~write_to_file.f90->sourcefile~math_integrate.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~write_to_file.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules math_integrate Source Code math_integrate.f90 Source Code module math_integrate use , intrinsic :: iso_fortran_env implicit none contains function volume_integrate ( f ) result ( result ) use constants_and_parameters , only : Nr , Nz , dr , dz , PI use global_variables , only : r_vec real ( real64 ), intent ( in ) :: f (:,:) real ( real64 ) :: result integer ( int32 ) :: r_size , z_size !real(real64)             :: Wr(Nr), Wz(Nz) r_size = size ( f , 1 ) z_size = size ( f , 2 ) if ( r_size /= Nr ) write ( * , * ) 'Error: r_size /= Nr' if ( z_size /= Nz ) write ( * , * ) 'Error: z_size /= Nz' !Wr(:) = r_vec(:)*dr;  !論文ではr=0でdr/2とかいているが、間違っている。円筒座標系ではr=0の体積要素が0なのでこのままでよい !Wz(:) = dz    ! ; Wz(1) = dz/2d0; Wz(Nz) = dz/2d0 result = 0 d0 block integer ( int32 ) :: i , j do j = 1 , Nz do i = 1 , Nr result = result + f ( i , j ) * r_vec ( i ) * dr * dz end do end do end block result = result * 2 d0 * PI return end function volume_integrate function sympson_volume_integrate ( f ) result ( result ) use constants_and_parameters , only : Nr , Nz , dr , dz , PI use global_variables , only : r_vec real ( real64 ), intent ( in ) :: f (:,:) real ( real64 ) :: result integer ( int32 ) :: r_size , z_size real ( real64 ) :: Wr ( Nr ), Wz ( Nz ) r_size = size ( f , 1 ) z_size = size ( f , 2 ) if ( r_size /= Nr ) write ( * , * ) 'Error: r_size /= Nr' if ( z_size /= Nz ) write ( * , * ) 'Error: z_size /= Nz' end function sympson_volume_integrate end module math_integrate","tags":"","loc":"sourcefile/math_integrate.f90.html"},{"title":"write_to_file.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~write_to_file.f90~~EfferentGraph sourcefile~write_to_file.f90 write_to_file.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~write_to_file.f90->sourcefile~constants_and_parameters.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~write_to_file.f90->sourcefile~global_variables.f90 sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~write_to_file.f90->sourcefile~math_integrate.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~global_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~write_to_file.f90~~AfferentGraph sourcefile~write_to_file.f90 write_to_file.f90 sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~write_to_file.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~write_to_file.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules write_to_file Source Code write_to_file.f90 Source Code module write_to_file use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: constants_and_parameters , only : resultdir , foldername implicit none contains subroutine outputsettings use constants_and_parameters , only : date , time , MMDDHHMMSS implicit none ! 現在の日付と時刻を取得 call date_and_time ( date , time ) ! フォルダ名を MMDD/HHMMSS 形式で設定 MMDDHHMMSS = date ( 5 : 8 ) // \"/\" // time ( 1 : 6 ) // \"/\" foldername = resultdir // MMDDHHMMSS ! フォルダ作成 (システム依存) call system ( \"mkdir -p \" // foldername ) call system ( \"mkdir -p \" // foldername // \"orbital_wavefunction/\" ) call system ( \"mkdir -p \" // foldername // \"densities/\" ) call system ( \"mkdir -p \" // foldername // \"potentials/\" ) print * , \"フォルダ名は\" // MMDDHHMMSS // \"です\" ! make output files(use append mode) call make_one_file ( \"sort_information.txt\" ) call make_one_file ( \"meanfield_Energy.txt\" ) call make_one_file ( \"mag_log.txt\" ) call make_one_file ( \"change_orbital.txt\" ) call make_one_file ( \"iter_Energy.txt\" ) end subroutine outputsettings subroutine make_one_file ( filename ) integer ( int32 ) :: fi , is = 1 character ( * ) :: filename character (:), allocatable :: alloc_filename allocate ( alloc_filename , source = filename ) open ( newunit = fi , file = foldername // filename , action = \"write\" , status = \"replace\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot make file.\" stop else if ( is == 0 ) then !print*, \"File created: \", filename end if close ( fi ) end subroutine make_one_file subroutine write_meanfield_Energy ( iter ) use global_variables , only : Skyrme_Energy , Kinetic_Energy , Coulomb_Energy , CM_Energy , Total_Energy implicit none integer ( int32 ) :: fi , is integer ( int32 ), intent ( in ) :: iter logical , save :: make_index = . true . character (:), allocatable :: filename allocate ( filename , source = \"meanfield_Energy.txt\" ) open ( newunit = fi , file = foldername // filename , action = \"write\" , position = \"append\" , status = \"old\" , iostat = is ) if ( is /= 0 ) print * , \"Error: cannot open file.\" , filename if ( make_index ) then write ( fi , * ) \"iter Kinetic Skyrme Coulomb CM Total\" make_index = . false . end if !write(fi, '(I5, G20.10, G20.10, G20.10, G20.10, G20.10)') & write ( fi , * ) & iter , Kinetic_Energy , Skyrme_Energy , Coulomb_Energy , CM_Energy , Total_Energy close ( fi ) end subroutine write_meanfield_Energy subroutine write_prep_sort ( iter ) use global_variables , only : one_E => prep_one_particle_E , one_Kin => prep_one_E_Kin , one_U => prep_one_E_U & , one_B => prep_one_E_B , one_W => prep_one_E_W & , m => prep_magnetic_q_num , idx => prep_idx_array , prep_number , init_rzm_to_write use constants_and_parameters , only : num_n , num_p implicit none integer ( int32 ) :: fi , is , prep integer ( int32 ), intent ( in ) :: iter logical , save :: make_index = . true . logical , save :: make_index2 = . true . character (:), allocatable :: filename , filename2 , filename3 allocate ( filename , source = \"sort_information.txt\" ) allocate ( filename2 , source = \"change_orbital.txt\" ) allocate ( filename3 , source = \"mag_log.txt\" ) open ( newunit = fi , file = foldername // filename , action = \"write\" , position = \"append\" , status = \"old\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename stop end if if ( make_index ) then write ( fi , * ) \"one_E_n Kin(u) Kin(d) U(u) U(d) B(u) B(d) W(u) W(d) m_n idx_n  |  & one_E_p Kin(u) Kin(d) U(u) U(d) B(u) B(d) W(u) W(d) m_p idx_p\" make_index = . false . else do prep = 1 , 2 ! 最初の2軌道だけを出力 もしかしたらidx(prep,1) -> idx(prep) が正しい !write(fi,*) & !            one_E(idx(prep,1),1), one_Kin(idx(prep,1),1,1), one_Kin(idx(prep,1),1,2) & !           ,one_U(idx(prep,1),1,1), one_U(idx(prep,1),1,2) & !           ,one_B(idx(prep,1),1,1), one_B(idx(prep,1),1,2) & !           ,one_W(idx(prep,1),1,1), one_W(idx(prep,1),1,2) & !           ,m(idx(prep,1),1), idx(prep,1), \"|\"& !           ,one_E(idx(prep,2),2), one_Kin(idx(prep,2),2,1), one_Kin(idx(prep,2),2,2) & !           ,one_U(idx(prep,2),2,1), one_U(idx(prep,2),2,2) & !           ,one_B(idx(prep,2),2,1), one_B(idx(prep,2),2,2) & !           ,one_W(idx(prep,2),2,1), one_W(idx(prep,2),2,2) & !           ,m(idx(prep,2),2), idx(prep,2) write ( fi , * ) & one_E ( prep , 1 ), one_Kin ( idx ( prep , 1 ), 1 , 1 ), one_Kin ( idx ( prep , 1 ), 1 , 2 ) & , one_U ( idx ( prep , 1 ), 1 , 1 ), one_U ( idx ( prep , 1 ), 1 , 2 ) & , one_B ( idx ( prep , 1 ), 1 , 1 ), one_B ( idx ( prep , 1 ), 1 , 2 ) & , one_W ( idx ( prep , 1 ), 1 , 1 ), one_W ( idx ( prep , 1 ), 1 , 2 ) & , m ( idx ( prep , 1 ), 1 ), idx ( prep , 1 ), \"|\" & , one_E ( prep , 2 ), one_Kin ( idx ( prep , 2 ), 2 , 1 ), one_Kin ( idx ( prep , 2 ), 2 , 2 ) & , one_U ( idx ( prep , 2 ), 2 , 1 ), one_U ( idx ( prep , 2 ), 2 , 2 ) & , one_B ( idx ( prep , 2 ), 2 , 1 ), one_B ( idx ( prep , 2 ), 2 , 2 ) & , one_W ( idx ( prep , 2 ), 2 , 1 ), one_W ( idx ( prep , 2 ), 2 , 2 ) & , m ( idx ( prep , 2 ), 2 ), idx ( prep , 2 ) end do end if write ( fi , * ) \"---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----\" close ( fi ) open ( newunit = fi , file = foldername // filename2 , action = \"write\" , position = \"append\" , status = \"old\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename2 stop end if if ( make_index2 ) then write ( fi , * ) \"one_E_n m_n idx_n one_E_p m_p idx_p\" make_index2 = . false . else do prep = 1 , prep_number write ( fi , * ) one_E ( prep , 1 ), m ( idx ( prep , 1 ), 1 ), idx ( prep , 1 )& , one_E ( prep , 2 ), m ( idx ( prep , 2 ), 2 ), idx ( prep , 2 ) end do end if write ( fi , * ) \"---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----\" close ( fi ) open ( newunit = fi , file = foldername // filename3 , action = \"write\" , position = \"append\" , status = \"old\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename3 stop end if write ( fi , \"(I6,1X)\" , advance = \"no\" ) iter do prep = 1 , num_n write ( fi , \"(A5,1X)\" , advance = \"no\" ) init_rzm_to_write ( idx ( prep , 1 )) end do write ( fi , \"(A1,1X)\" , advance = \"no\" ) \"|\" do prep = 1 , num_p write ( fi , \"(A5,1X)\" , advance = \"no\" ) init_rzm_to_write ( idx ( prep , 2 )) end do write ( fi , * ) close ( fi ) end subroutine write_prep_sort subroutine write_wavefunction ( num ) use global_variables , only : wf_plus , wf_minus , r_vec , z_vec use constants_and_parameters , only : Nr , Nz , num_n implicit none integer ( int32 ), intent ( in ) :: num integer ( int32 ) :: i , j , k , is = 1 , fi character (:), allocatable :: filename character ( 10 ) :: char4 write ( char4 , \"(i0)\" ) num allocate ( filename , source = \"wavefunc\" ) open ( newunit = fi , file = foldername // \"orbital_wavefunction/\" // filename // trim ( char4 ) // \".txt\" & , action = \"write\" , status = \"new\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename // char4 stop end if write ( fi , * ) \"r z wfn1u wfn1d wfn2u wfn2d wfp1u wfp1d wfp2u wfp2d\" do i = 1 , Nr do j = 1 , Nz ! ここで先に i*dr と j*dz を出力 write ( fi , '(F8.3, F8.3)' , advance = 'no' ) r_vec ( i ), z_vec ( j ) ! ここで5次元配列の指定された要素を出力 do k = 1 , 2 write ( fi , '(4F24.17)' , advance = 'no' )& wf_plus ( i , j , k ), wf_minus ( i , j , k ) end do do k = 1 , 2 write ( fi , '(4F24.17)' , advance = 'no' )& wf_plus ( i , j , num_n + k ), wf_minus ( i , j , num_n + k ) end do ! 新しい行に進むための改行 write ( fi , * ) end do end do close ( fi ) deallocate ( filename ) end subroutine write_wavefunction subroutine write_d_wavefunction ( num ) use global_variables , only : r_vec , z_vec , dr_wf_plus , dr_wf_minus , dz_wf_plus , dz_wf_minus use constants_and_parameters , only : Nr , Nz , num_n , num_p implicit none integer ( int32 ), intent ( in ) :: num integer ( int32 ) :: i , j , k , is = 1 , fi character (:), allocatable :: filename character ( 10 ) :: char4 write ( char4 , \"(i0)\" ) num allocate ( filename , source = \"wavefunc_d\" ) open ( newunit = fi , file = foldername // \"orbital_wavefunction/\" // filename // trim ( char4 ) // \".txt\" & , action = \"write\" , status = \"new\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename // char4 stop end if write ( fi , * ) \"r z dr_wfn1u dz_wfn1u dr_wfn1d dz_wfn1d & dr_wfn2u dz_wfn2u dr_wfn2d dz_wfn2d & dr_wfp1u dz_wfp1u dr_wfp1d dz_wfp1d & dr_wfp2u dz_wfp2u dr_wfp2d dz_wfp2d \" do i = 1 , Nr do j = 1 , Nz ! ここで先に i*dr と j*dz を出力 write ( fi , '(F8.3, F8.3)' , advance = 'no' ) r_vec ( i ), z_vec ( j ) ! ここで5次元配列の指定された要素を出力 do k = 1 , 2 write ( fi , '(8F24.17)' , advance = 'no' )& dr_wf_plus ( i , j , k ), dz_wf_plus ( i , j , k ), dr_wf_minus ( i , j , k ), dz_wf_minus ( i , j , k ) end do do k = 1 , 2 write ( fi , '(8F24.17)' , advance = 'no' )& dr_wf_plus ( i , j , num_n + k ), dz_wf_plus ( i , j , num_n + k ), dr_wf_minus ( i , j , num_n + k ), dz_wf_minus ( i , j , num_n + k ) end do ! 新しい行に進むための改行 write ( fi , * ) end do end do close ( fi ) deallocate ( filename ) end subroutine write_d_wavefunction subroutine write_density_and_derivative ( num ) use constants_and_parameters , only : Nr , Nz use global_variables , only : rho_n , rho_p , lap_rho_n , lap_rho_p , dr_rho_n , dr_rho_p , dz_rho_n , dz_rho_p & , ddr_rho_n , ddr_rho_p , ddz_rho_n , ddz_rho_p & , tau_n => kinetic_dens_n , tau_p => kinetic_dens_p & , thomas_fermi_n , thomas_fermi_p & , j_n => spin_orbit_dens_n , j_p => spin_orbit_dens_p & , divj_n => div_spin_orbit_dens_n , divj_p => div_spin_orbit_dens_p , r_vec , z_vec implicit none character (:), allocatable :: filename integer ( int32 ), intent ( in ) :: num integer ( int32 ) :: is = 1 , fi integer ( int32 ) :: i , j character ( 10 ) :: char4 write ( char4 , \"(i0)\" ) num allocate ( filename , source = \"density_and_derivative\" ) open ( newunit = fi , file = foldername // \"densities/\" // filename // trim ( char4 ) // \".txt\" & , action = \"write\" , status = \"new\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename // char4 stop end if write ( fi , * ) \"r z & rho_n dr_rho_n dz_rho_n ddr_rho_n ddz_rho_n lap_rho_n & rho_p dr_rho_p dz_rho_p ddr_rho_p ddz_rho_p lap_rho_p & tau_n tau_p jr_n jz_n divj_n jr_p jz_p divj_p thor_n thor_p\" do i = 1 , Nr do j = 1 , Nz !write(fi,\"(F8.3, F8.3, G20.10, G20.10, G20.10, G20.10, & !                       G20.10, G20.10, & !                       G20.10, G20.10, G20.10, G20.10, G20.10, G20.10)\") & write ( fi , * ) & r_vec ( i ), z_vec ( j )& , rho_n ( i , j ), dr_rho_n ( i , j ), dz_rho_n ( i , j ), ddr_rho_n ( i , j ), ddz_rho_n ( i , j ), lap_rho_n ( i , j )& , rho_p ( i , j ), dr_rho_p ( i , j ), dz_rho_p ( i , j ), ddr_rho_p ( i , j ), ddz_rho_p ( i , j ), lap_rho_p ( i , j ) & , tau_n ( i , j ), tau_p ( i , j ) & , j_n ( i , j , 1 ), j_n ( i , j , 3 ), divj_n ( i , j ), j_p ( i , j , 1 ), j_p ( i , j , 3 ), divj_p ( i , j ) & , thomas_fermi_n ( i , j ), thomas_fermi_p ( i , j ) end do end do close ( fi ) deallocate ( filename ) end subroutine write_density_and_derivative subroutine write_pot ( num ) use constants_and_parameters , only : Nr , Nz , bkin => HBAR2_over_2m use global_variables , only : U_n , U_p , B_n , B_p , W_n , W_p , Cou => direct_Coulomb_pot , r_vec , z_vec implicit none integer ( int32 ), intent ( in ) :: num integer ( int32 ) :: i , j , is = 1 , fi character (:), allocatable :: filename character ( 10 ) :: char4 write ( char4 , \"(i0)\" ) num allocate ( filename , source = \"pot\" ) open ( newunit = fi , file = foldername // \"potentials/\" // filename // trim ( char4 ) // \".txt\" & , action = \"write\" , status = \"new\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename // char4 stop end if write ( fi , * ) \"r z Coulomb U_n U_p B_n B_p Wr_n Wz_n, Wr_p Wz_p\" do i = 1 , Nr do j = 1 , Nz ! write(fi, '(F8.3, F8.3, G20.10, G20.10, G20.10, G20.10, G20.10, G20.10, G20.10, G20.10, G20.10)') & write ( fi , * ) & r_vec ( i ), z_vec ( j ), Cou ( i , j ), U_n ( i , j ), U_p ( i , j ), B_n ( i , j ) + bkin , B_p ( i , j ) + bkin & , W_n ( i , j , 1 ), W_n ( i , j , 3 ), W_p ( i , j , 1 ), W_p ( i , j , 3 ) end do end do close ( fi ) deallocate ( filename ) end subroutine write_pot subroutine write_U_term ( b0 , b0p , b1 , b1p , b2 , b2p , b3 , b3p , b3p2 , b4 , b4p , dir , ex , np_str ) use constants_and_parameters , only : Nr , Nz , max_iter use global_variables , only : r_vec , z_vec implicit none real ( real64 ), intent ( in ) :: b0 (:,:), b0p (:,:), b1 (:,:), b1p (:,:), b2 (:,:), b2p (:,:)& , b3 (:,:), b3p (:,:), b3p2 (:,:), b4 (:,:), b4p (:,:), dir (:,:), ex (:,:) character ( len = 1 ), intent ( in ) :: np_str integer ( int32 ), save :: num = 0 integer ( int32 ) :: i , j , is = 1 , fi character (:), allocatable :: filename character ( 10 ) :: char4 write ( char4 , \"(i0)\" ) num if ( num /= 0. or . num /= max_iter ) then return end if allocate ( filename , source = \"U_term\" ) open ( newunit = fi , file = foldername // \"potentials/\" // filename // np_str // char4 // \".txt\" , action = \"write\" , status = \"new\" , iostat = is ) if ( is /= 0 ) then print * , \"Error: cannot open file.\" , filename // np_str // char4 stop end if write ( fi , * ) \"r z b0 b0p b1 b1p b2 b2p b3 b3p b3p2 b4 b4p dir ex\" do j = 1 , Nz do i = 1 , Nr write ( fi , * )& r_vec ( i ), z_vec ( j ), b0 ( i , j ), b0p ( i , j ), b1 ( i , j ), b1p ( i , j ), b2 ( i , j ), b2p ( i , j )& , b3 ( i , j ), b3p ( i , j ), b3p2 ( i , j ), b4 ( i , j ), b4p ( i , j ), dir ( i , j ), ex ( i , j ) end do end do close ( fi ) deallocate ( filename ) if ( np_str == \"p\" ) then num = num + 1 end if end subroutine write_U_term subroutine write_iter_Energy ( iter ) use global_variables , only : Skyrme_Energy , Kinetic_Energy , Coulomb_Energy , CM_Energy , Total_Energy , & b_0_term , b_3_term , b_2_term , b_1_term , b_4_term , c_1_term implicit none integer ( int32 ) :: fi , is integer ( int32 ), intent ( in ) :: iter logical , save :: make_index = . true . character (:), allocatable :: filename allocate ( filename , source = \"iter_Energy.txt\" ) open ( newunit = fi , file = foldername // filename , action = \"write\" , position = \"append\" , status = \"old\" , iostat = is ) if ( is /= 0 ) print * , \"Error: cannot open file.\" , filename if ( make_index ) then write ( fi , * ) \"Total Kinetic Coulomb CM Skyrme b_0 b_1 b_2 b_3 b_4 c_1\" make_index = . false . end if !write(fi,'(f10.3,f10.3,f10.3,f10.3,f10.3,f10.3,f10.3,f10.3,f10.3,f10.3,f10.3)')  & write ( fi , * ) & Total_Energy , Kinetic_Energy , Coulomb_Energy , CM_Energy , Skyrme_Energy , & b_0_term , b_1_term , b_2_term , b_3_term , b_4_term , c_1_term close ( fi ) end subroutine write_iter_Energy function overlap_to_file ( idx_1 , idx_2 ) result ( ovlp ) use math_integrate , only : volume_integrate use global_variables , only : wf_plus , wf_minus implicit none integer ( int32 ), intent ( in ) :: idx_1 integer ( int32 ), intent ( in ) :: idx_2 real ( real64 ) :: ovlp real ( real64 ) :: term_plus , term_minus term_plus = volume_integrate ( f = wf_plus (:,:, idx_1 ) * wf_plus (:,:, idx_2 )) term_minus = volume_integrate ( f = wf_minus (:,:, idx_1 ) * wf_minus (:,:, idx_2 )) ovlp = term_plus + term_minus end function overlap_to_file end module write_to_file","tags":"","loc":"sourcefile/write_to_file.f90.html"},{"title":"determine_observables.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~determine_observables.f90~~EfferentGraph sourcefile~determine_observables.f90 determine_observables.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~determine_observables.f90->sourcefile~constants_and_parameters.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~determine_observables.f90->sourcefile~global_variables.f90 sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~determine_observables.f90->sourcefile~math_integrate.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~global_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~determine_observables.f90~~AfferentGraph sourcefile~determine_observables.f90 determine_observables.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~determine_observables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules determine_observables Source Code determine_observables.f90 Source Code module determine_observables implicit none contains subroutine calc_Skyrme_Energy_by_integrate use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : b_0 , b_0p , b_3 , b_3p , b_2 , b_2p , b_1 , b_1p , b_4 , b_4p , c_1 , c_1p , param_gamma & , Nr , Nz use global_variables , only : Skyrme_Energy , b_0_term , b_3_term , b_2_term , b_1_term , b_4_term , c_1_term use math_integrate , only : volume_integrate use global_variables , only : rho_n , rho_p , lap_rho_n , lap_rho_p & , tau_n => kinetic_dens_n , tau_p => kinetic_dens_p & , j_n => spin_orbit_dens_n , j_p => spin_orbit_dens_p & , div_j_n => div_spin_orbit_dens_n , div_j_p => div_spin_orbit_dens_p implicit none real ( real64 ), allocatable :: rho (:,:), lap_rho (:,:), tau (:,:), j (:,:,:), div_j (:,:) allocate ( rho ( Nr , Nz )) allocate ( lap_rho ( Nr , Nz )) allocate ( tau ( Nr , Nz )) allocate ( j ( Nr , Nz , 3 )) allocate ( div_j ( Nr , Nz )) rho (:,:) = rho_n (:,:) + rho_p (:,:) lap_rho (:,:) = lap_rho_n (:,:) + lap_rho_p (:,:) tau (:,:) = tau_n (:,:) + tau_p (:,:) j (:,:,:) = j_n (:,:,:) + j_p (:,:,:) div_j (:,:) = div_j_n (:,:) + div_j_p (:,:) b_0_term = volume_integrate ( b_0 / 2.0d0 * ( rho (:,:)) ** 2 - b_0p / 2.0d0 * ( rho_n (:,:) ** 2 + rho_p (:,:) ** 2 )) b_3_term = volume_integrate ( b_3 / 3.0d0 * ( rho (:,:)) ** ( param_gamma + 2.0d0 ) & - b_3p / 3.0d0 * rho (:,:) ** ( param_gamma ) * ( rho_n (:,:) ** 2 + rho_p (:,:) ** 2 )) b_2_term = volume_integrate ( - b_2 / 2.0d0 * rho (:,:) * lap_rho (:,:) & + b_2p / 2.0d0 * ( rho_n (:,:) * lap_rho_n (:,:) + rho_p (:,:) * lap_rho_p (:,:))) b_1_term = volume_integrate ( b_1 * rho (:,:) * tau (:,:) - b_1p * ( rho_n (:,:) * tau_n (:,:) + rho_p (:,:) * tau_p (:,:))) b_4_term = volume_integrate ( b_4 * rho (:,:) * div_j (:,:) + b_4p * ( rho_n (:,:) * div_j_n (:,:) + rho_p (:,:) * div_j_p (:,:))) c_1_term = volume_integrate ( c_1 * ( j (:,:, 1 ) ** 2 + j (:,:, 3 ) ** 2 ) & - c_1p * ( j_n (:,:, 1 ) ** 2 + j_n (:,:, 3 ) ** 2 ) & - c_1p * ( j_p (:,:, 1 ) ** 2 + j_p (:,:, 3 ) ** 2 )) Skyrme_Energy = b_0_term + b_3_term + b_2_term + b_1_term - b_4_term - c_1_term deallocate ( rho ) deallocate ( lap_rho ) deallocate ( tau ) deallocate ( j ) deallocate ( div_j ) end subroutine calc_Skyrme_Energy_by_integrate subroutine calc_Kinetic_Energy_by_integrate use constants_and_parameters , only : HBAR2_over_2m use global_variables , only : Kinetic_Energy use math_integrate , only : volume_integrate use global_variables , only : tau_n => kinetic_dens_n , tau_p => kinetic_dens_p implicit none Kinetic_Energy = HBAR2_over_2m * volume_integrate ( tau_n (:,:) + tau_p (:,:)) end subroutine calc_Kinetic_Energy_by_integrate subroutine calc_Coulomb_Energy use global_variables , only : direct_Coulomb_pot , exchange_Coulomb_pot , Coulomb_Energy , rho_p use math_integrate , only : volume_integrate implicit none Coulomb_Energy = volume_integrate ( rho_p (:,:) * ( direct_Coulomb_pot (:,:) / 2 d0 - 3 d0 / 4 d0 * exchange_Coulomb_pot (:,:))) end subroutine calc_Coulomb_Energy subroutine calc_CM_Energy use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : mass_of_neutron , mass_of_proton , num_n , num_p use global_variables , only : CM_Energy implicit none integer ( int32 ) :: k , kp real ( real64 ) :: MC2_tot CM_Energy = 0 d0 do k = 1 , num_n CM_Energy = CM_Energy + calc_PC2_ExV ( k ) end do do k = 1 , num_p kp = k + num_n CM_Energy = CM_Energy + calc_PC2_ExV ( kp ) end do MC2_tot = num_n * mass_of_neutron + num_p * mass_of_proton CM_Energy = CM_Energy / ( 2.0d0 * MC2_tot ) end subroutine calc_CM_Energy function calc_PC2_ExV ( nuc_idx ) result ( expected_value ) ! calculate (PC)&#94;2 expectation value use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : HBARC use global_variables , only : wf_plus , wf_minus , lap_wf_plus , lap_wf_minus use math_integrate , only : volume_integrate implicit none integer ( int32 ), intent ( in ) :: nuc_idx real ( real64 ) :: expected_value expected_value = - ( HBARC ) ** 2 * volume_integrate ( wf_plus (:,:, nuc_idx ) * lap_wf_plus (:,:, nuc_idx ) & + wf_minus (:,:, nuc_idx ) * lap_wf_minus (:,:, nuc_idx )) end function calc_PC2_ExV subroutine calc_Total_Energy use global_variables , only : Total_Energy , Skyrme_Energy , Kinetic_Energy , Coulomb_Energy , CM_Energy Total_Energy = Skyrme_Energy + Kinetic_Energy + Coulomb_Energy - CM_Energy end subroutine calc_Total_Energy end module determine_observables","tags":"","loc":"sourcefile/determine_observables.f90.html"},{"title":"global_variables.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~global_variables.f90~~EfferentGraph sourcefile~global_variables.f90 global_variables.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~global_variables.f90~~AfferentGraph sourcefile~global_variables.f90 global_variables.f90 sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~global_variables.f90 sourcefile~solve_poisson_problem.f90 solve_poisson_problem.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~solve_poisson_problem.f90 sourcefile~write_to_file.f90 write_to_file.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~write_to_file.f90 sourcefile~determine_observables.f90 determine_observables.f90 sourcefile~determine_observables.f90->sourcefile~global_variables.f90 sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~determine_observables.f90->sourcefile~math_integrate.f90 sourcefile~harmonic_occ.f90 harmonic_occ.f90 sourcefile~harmonic_occ.f90->sourcefile~global_variables.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~global_variables.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 sourcefile~main.f90->sourcefile~determine_observables.f90 sourcefile~main.f90->sourcefile~harmonic_occ.f90 sourcefile~main.f90->sourcefile~math_integrate.f90 sourcefile~main.f90->sourcefile~write_to_file.f90 sourcefile~math_integrate.f90->sourcefile~global_variables.f90 sourcefile~solve_poisson_problem.f90->sourcefile~global_variables.f90 sourcefile~write_to_file.f90->sourcefile~global_variables.f90 sourcefile~write_to_file.f90->sourcefile~math_integrate.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules global_variables Source Code global_variables.f90 Source Code module global_variables use , intrinsic :: iso_fortran_env use constants_and_parameters implicit none !-- Density and potential (caluculated by Occupied Orbitals) -- real ( real64 ) , allocatable :: rho_n (:,:) ! [fm&#94;-3]  (r,z) real ( real64 ) , allocatable :: rho_p (:,:) ! [fm&#94;-3]  (r,z) real ( real64 ) , allocatable :: dr_rho_n (:,:) real ( real64 ) , allocatable :: dz_rho_n (:,:) real ( real64 ) , allocatable :: dr_rho_p (:,:) real ( real64 ) , allocatable :: dz_rho_p (:,:) real ( real64 ) , allocatable :: ddr_rho_n (:,:) real ( real64 ) , allocatable :: ddz_rho_n (:,:) real ( real64 ) , allocatable :: ddr_rho_p (:,:) real ( real64 ) , allocatable :: ddz_rho_p (:,:) real ( real64 ) , allocatable :: lap_rho_n (:,:) ! [fm&#94;-5]  (r,z) real ( real64 ) , allocatable :: lap_rho_p (:,:) ! [fm&#94;-5]  (r,z) real ( real64 ) , allocatable :: kinetic_dens_n (:,:) ! [fm&#94;-3]  (r,z) real ( real64 ) , allocatable :: kinetic_dens_p (:,:) ! [fm&#94;-3]  (r,z) real ( real64 ) , allocatable :: thomas_fermi_n (:,:) ! [fm&#94;-4]  (r,z) real ( real64 ) , allocatable :: thomas_fermi_p (:,:) ! [fm&#94;-4]  (r,z) real ( real64 ) , allocatable :: spin_orbit_dens_n (:,:,:) ! [fm&#94;-3]  (r,z,vec component) real ( real64 ) , allocatable :: spin_orbit_dens_p (:,:,:) ! [fm&#94;-3]  (r,z,vec component) real ( real64 ) , allocatable :: div_spin_orbit_dens_n (:,:) ! [fm&#94;-4]  (r,z) real ( real64 ) , allocatable :: div_spin_orbit_dens_p (:,:) ! [fm&#94;-4]  (r,z) real ( real64 ) , allocatable :: U_n (:,:) ! [MeV] (r,z) real ( real64 ) , allocatable :: U_p (:,:) ! [MeV] (r,z) real ( real64 ) , allocatable :: B_n (:,:) ! [MeV] (r,z) real ( real64 ) , allocatable :: B_p (:,:) ! [MeV] (r,z) real ( real64 ) , allocatable :: W_n (:,:,:) ! [MeV] (r,z,component) real ( real64 ) , allocatable :: W_p (:,:,:) ! [MeV] (r,z,component) real ( real64 ) , allocatable :: direct_Coulomb_pot (:,:) ! [MeV] (r,z) real ( real64 ) , allocatable :: exchange_Coulomb_pot (:,:) ! [MeV] (r,z) ! -- All Orbitals(Occupied state / All state : prefix = prep(last component is n or p)) -- integer ( int32 ) , allocatable :: prep_idx_array (:,:) ! nucleon index (prepared) integer ( int32 ) , allocatable :: magnetic_q_num (:) ! magnetic quantum number integer ( int32 ) , allocatable :: prep_magnetic_q_num (:,:) ! magnetic quantum number (prepared) character ( 4 ) , allocatable :: init_rzm_to_write (:) ! write quantum number (only to write) real ( real64 ) , allocatable :: prep_one_particle_E (:,:) ! [MeV] 1粒子エネルギー (prepared) real ( real64 ) , allocatable :: prep_one_particle_E2 (:,:) ! [MeV2] <α|h&#94;2|α> (prepared) prep, n/p, u/d real ( real64 ) , allocatable :: prep_one_E_Kin (:,:,:) ! [MeV] 1粒子エネルギー (prepared) prep, n/p, u/d real ( real64 ) , allocatable :: prep_one_E_U (:,:,:) ! [MeV] 1粒子エネルギー (prepared) real ( real64 ) , allocatable :: prep_one_E_B (:,:,:) ! [MeV] 1粒子エネルギー (prepared) real ( real64 ) , allocatable :: prep_one_E_W (:,:,:) ! [MeV] 1粒子エネルギー (prepared) real ( real64 ) , allocatable :: wf_plus (:,:,:) ! [fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: wf_minus (:,:,:) ! [fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: prep_wf_plus (:,:,:,:) ! [fm&#94;-3/2]  (r,z,prepsize, n/p) real ( real64 ) , allocatable :: prep_wf_minus (:,:,:,:) ! [fm&#94;-3/2]  (r,z,prepsize, n/p) !----- derivative of wave function ----- real ( real64 ) , allocatable :: dr_wf_plus (:,:,:) real ( real64 ) , allocatable :: dz_wf_plus (:,:,:) real ( real64 ) , allocatable :: ddr_wf_plus (:,:,:) real ( real64 ) , allocatable :: ddz_wf_plus (:,:,:) real ( real64 ) , allocatable :: lap_wf_plus (:,:,:) real ( real64 ) , allocatable :: prep_dr_wf_plus (:,:,:,:) real ( real64 ) , allocatable :: prep_dz_wf_plus (:,:,:,:) real ( real64 ) , allocatable :: prep_ddr_wf_plus (:,:,:,:) real ( real64 ) , allocatable :: prep_ddz_wf_plus (:,:,:,:) real ( real64 ) , allocatable :: prep_lap_wf_plus (:,:,:,:) real ( real64 ) , allocatable :: dr_wf_minus (:,:,:) real ( real64 ) , allocatable :: dz_wf_minus (:,:,:) real ( real64 ) , allocatable :: ddr_wf_minus (:,:,:) real ( real64 ) , allocatable :: ddz_wf_minus (:,:,:) real ( real64 ) , allocatable :: lap_wf_minus (:,:,:) real ( real64 ) , allocatable :: prep_dr_wf_minus (:,:,:,:) real ( real64 ) , allocatable :: prep_dz_wf_minus (:,:,:,:) real ( real64 ) , allocatable :: prep_ddr_wf_minus (:,:,:,:) real ( real64 ) , allocatable :: prep_ddz_wf_minus (:,:,:,:) real ( real64 ) , allocatable :: prep_lap_wf_minus (:,:,:,:) real ( real64 ) , allocatable :: prep_Upsi_plus (:,:,:,:) real ( real64 ) , allocatable :: prep_Upsi_minus (:,:,:,:) real ( real64 ) , allocatable :: prep_Bpsi_plus (:,:,:,:) real ( real64 ) , allocatable :: prep_Bpsi_minus (:,:,:,:) real ( real64 ) , allocatable :: prep_Wpsi_plus (:,:,:,:) real ( real64 ) , allocatable :: prep_Wpsi_minus (:,:,:,:) !----- use for calculation ----- ! SDNWP/M = sigma dot nabla plus/minus real ( real64 ) , allocatable :: SDNWP (:,:,:) ! [fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: SDNWM (:,:,:) ! [fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: prep_SDNWP (:,:,:,:) ! [fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: prep_SDNWM (:,:,:,:) ! [fm&#94;-3/2]  (r,z,nucleon) ! Hpsi real ( real64 ) , allocatable :: prep_Hpsi2_plus (:,:,:,:) ! [MeV fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: prep_Hpsi2_minus (:,:,:,:) ! [MeV fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: prep_Hpsi_plus (:,:,:,:) ! [MeV fm&#94;-3/2]  (r,z,nucleon) real ( real64 ) , allocatable :: prep_Hpsi_minus (:,:,:,:) ! [MeV fm&#94;-3/2]  (r,z,nucleon) !-- Grid variables -- real ( real64 ) , allocatable :: r_vec (:) ! [fm] r position real ( real64 ) , allocatable :: z_vec (:) ! [fm] z position !-- Observables -- real ( real64 ) :: Skyrme_Energy real ( real64 ) :: Kinetic_Energy real ( real64 ) :: Coulomb_Energy real ( real64 ) :: CM_Energy real ( real64 ) :: Total_Energy real ( real64 ) :: Avarage_variance real ( real64 ) :: b_0_term , b_3_term , b_2_term , b_1_term , b_4_term , c_1_term end module global_variables","tags":"","loc":"sourcefile/global_variables.f90.html"},{"title":"solve_poisson_problem.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~solve_poisson_problem.f90~~EfferentGraph sourcefile~solve_poisson_problem.f90 solve_poisson_problem.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~solve_poisson_problem.f90->sourcefile~constants_and_parameters.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~solve_poisson_problem.f90->sourcefile~global_variables.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~solve_poisson_problem.f90~~AfferentGraph sourcefile~solve_poisson_problem.f90 solve_poisson_problem.f90 sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~solve_poisson_problem.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules poisson_problem Source Code solve_poisson_problem.f90 Source Code module poisson_problem contains subroutine use_DGESV ( N , A , b , res_x ) use , intrinsic :: iso_fortran_env implicit none integer , intent ( in ) :: N real ( kind = 8 ), intent ( in ) :: A (:,:) real ( kind = 8 ), intent ( in ) :: b (:) real ( kind = 8 ), intent ( out ) :: res_x (:) integer ( int32 ) :: lda , ldb , NRHS , INFO integer ( int32 ), allocatable :: IPIV (:) real ( real64 ), allocatable :: A_lapack (:,:), b_lapack (:) allocate ( IPIV ( N )) allocate ( A_lapack ( N , N )) allocate ( b_lapack ( N )) A_lapack (:,:) = A (:,:) b_lapack (:) = b (:) lda = N ldb = N NRHS = 1 call DGESV ( N , NRHS , A_lapack , lda , IPIV , b_lapack , ldb , INFO ) if ( INFO /= 0 ) then write ( * , * ) \"Error in DGESV\" write ( * , * ) INFO stop end if res_x (:) = b_lapack (:) write ( * , * ) \"DGESV finished\" !write(*,*) b_lapack deallocate ( IPIV ) deallocate ( A_lapack ) deallocate ( b_lapack ) end subroutine use_DGESV ! r=0付近は偶関数の条件→行列の生成時に取り入れる ! r=Nr,z=0,z=Nzはディリクレ境界条件→解くべき行列の大きさは(Nr-1)*(Nz-2) subroutine nine_point_poisson_by_lapack ( rho_p , coulomb ) use , intrinsic :: iso_fortran_env use constants_and_parameters , e2 => elementary_charge2 use global_variables , only : r_vec real ( real64 ), intent ( in ) :: rho_p (:,:) real ( real64 ), intent ( out ) :: coulomb (:,:) real ( real64 ), allocatable :: A (:,:), b (:), res_x (:) ! solve Ax=b. res_x is the solution real ( real64 ) :: dd_weight ( - 4 : 4 ) = [ - 9 d0 , 128 d0 , - 1008 d0 , 8064 d0 , - 14350 d0 , 8064 d0 , - 1008 d0 , 128 d0 , - 9 d0 ] real ( real64 ) :: d_weight ( - 4 : 4 ) = [ 3 d0 , - 32 d0 , 168 d0 , - 672 d0 , 0 d0 , 672 d0 , - 168 d0 , 32 d0 , - 3 d0 ] real ( real64 ) :: ddr_coef ( - 4 : 4 ), ddz_coef ( - 4 : 4 ) real ( real64 ) :: dr_coef ( - 4 : 4 ), dz_coef ( - 4 : 4 ) real ( real64 ) :: f_tmp ( - 4 : 4 ) integer ( int32 ) :: size_A integer ( int32 ) :: i , j , k integer ( int32 ) :: r_idx , z_idx , ir_idx , iz_idx logical :: is_outside_r , is_outside_z size_A = ( Nr - 1 ) * ( Nz - 2 ) allocate ( A ( size_A , size_A )) allocate ( b ( size_A )) allocate ( res_x ( size_A )) f_tmp (:) = 0 d0 ddr_coef (:) = dd_weight (:) / ( 5040 d0 * dr * dr ) ddz_coef (:) = dd_weight (:) / ( 5040 d0 * dz * dz ) dr_coef (:) = d_weight (:) / ( 840 d0 * dr ) dz_coef (:) = d_weight (:) / ( 840 d0 * dz ) A (:,:) = 0 d0 do k = 1 , size_A r_idx = modulo ( k - 1 , Nr - 1 ) + 1 z_idx = ( k - 1 ) / ( Nr - 1 ) + 2 do i =- 4 , 4 is_outside_r = . false . ir_idx = r_idx + i if ( ir_idx >= 1. and . ir_idx <= Nr - 1 ) then ! rは1からNr-1までを考えている ir_idx = ir_idx elseif ( ir_idx < 1 ) then ! 偶関数の条件 ir_idx = - ( ir_idx - 1 ) elseif ( ir_idx > Nr - 1 ) then ! rの外に出るとき（加わるものをゼロにする） is_outside_r = . true . end if if ( is_outside_r ) then ! 何もしない else A ( k , get_k ( ir_idx , z_idx )) = A ( k , get_k ( ir_idx , z_idx )) + ddr_coef ( i ) + dr_coef ( i ) * r_vec ( r_idx ) end if end do do j =- 4 , 4 is_outside_z = . false . iz_idx = z_idx + j if ( iz_idx >= 2. and . iz_idx <= Nz - 1 ) then ! zは2からNz-1までを考えている iz_idx = iz_idx elseif ( iz_idx < 2 ) then is_outside_z = . true . elseif ( iz_idx > Nr - 1 ) then is_outside_z = . true . end if if ( is_outside_z ) then ! 何もしない else A ( k , get_k ( r_idx , iz_idx )) = A ( k , get_k ( r_idx , iz_idx )) + ddz_coef ( j ) end if end do end do ! ディリクレ境界上では値を0とするので，b内で値を引き算する必要はなし． ! r=1の条件は行列に反映されている． b (:) = 0.0d0 ! ここでbを定義する do k = 1 , size_A r_idx = modulo ( k - 1 , Nr - 1 ) + 1 z_idx = ( k - 1 ) / ( Nr - 1 ) + 2 b ( k ) = - 4 d0 * PI * e2 * rho_p ( r_idx , z_idx ) ! \\laplacian \\phi = -4\\pi e&#94;2 \\rho_p end do call use_DGESV ( size_A , A (:,:), b (:), res_x (:)) ! ここでres_xをcoulombに代入する do k = 1 , size_A r_idx = modulo ( k - 1 , Nr - 1 ) + 1 z_idx = ( k - 1 ) / ( Nr - 1 ) + 2 coulomb ( r_idx , z_idx ) = res_x ( k ) end do deallocate ( A ) deallocate ( b ) deallocate ( res_x ) end subroutine nine_point_poisson_by_lapack subroutine three_point_poisson_by_lapack ( rho_p , A , b ) use constants_and_parameters , e2 => elementary_charge2 use , intrinsic :: iso_fortran_env implicit none real ( real64 ), intent ( in ) :: rho_p (:,:) real ( real64 ), intent ( out ) :: A (:,:) real ( real64 ), intent ( out ) :: b (:) integer ( int32 ) :: N ! (Nr-1)*(Nz-2) real ( real64 ) :: r real ( real64 ) :: A0 , Ap1 , Am1 , A2 ! 差分方程式の係数 integer ( int32 ) :: r_idx , z_idx ! 1次元配列のインデックスからi,jを復元するための変数 integer ( int32 ) :: k N = ( Nr - 1 ) * ( Nz - 2 ) if ( size ( A , 1 ) /= N . or . size ( A , 2 ) /= N ) then write ( * , * ) \"Error in make_matrix_of_poisson\" write ( * , * ) \"size of A is not correct\" stop end if if ( size ( b ) /= N ) then write ( * , * ) \"Error in make_matrix_of_poisson\" write ( * , * ) \"size of b is not correct\" stop end if A0 = - ( 2.0d0 / ( dr * dr ) + 2.0d0 / ( dz * dz )) Ap1 = 0.0d0 !ここだけはループ内で変更 Am1 = 0.0d0 !ここだけはループ内で変更 A2 = 1.0d0 / ( dz * dz ) ! 行列Aの生成 ! A(k,k)がf(i,j)に対応する。jを固定して先にiを変えていく。 ! r_idx = modulo(k-1,Nr-1)+1, z_idx = (k-1)/(Nr-1)+2 ! (z_idx-2)*(Nr-1) + r_idx で一次元配列の位置を復元できる A (:,:) = 0.0d0 do k = 1 , N r_idx = modulo ( k - 1 , Nr - 1 ) + 1 z_idx = ( k - 1 ) / ( Nr - 1 ) + 2 r = dble ( r_idx ) * dr Ap1 = 1 d0 / ( dr ) ** 2 + 1 d0 / ( 2 d0 * dr * r ) Am1 = 1 d0 / ( dr ) ** 2 - 1 d0 / ( 2 d0 * dr * r ) if ( r_idx == 1 ) then if ( z_idx == 2 ) then A ( k , k ) = A ( k , k ) + A0 A ( k , get_k ( r_idx + 1 , z_idx )) = A ( k , get_k ( r_idx + 1 , z_idx )) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( 1 , z_idx )) = A ( k , get_k ( 1 , z_idx )) + Am1 ! f(i-1,j)の係数 A ( k , get_k ( r_idx , z_idx + 1 )) = A ( k , get_k ( r_idx , z_idx + 1 )) + A2 ! f(i,j+1)の係数 !A(k,get_k(r_idx,z_idx-1)) = A(k,get_k(r_idx,z_idx-1)) + A2  ! f(i,j-1)の係数 else if ( z_idx == Nz - 1 ) then A ( k , k ) = A ( k , k ) + A0 A ( k , get_k ( r_idx + 1 , z_idx )) = A ( k , get_k ( r_idx + 1 , z_idx )) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( 1 , z_idx )) = A ( k , get_k ( 1 , z_idx )) + Am1 ! f(i-1,j)の係数 !A(k,get_k(r_idx,z_idx+1)) = A(k,get_k(r_idx,z_idx+1)) + A2  ! f(i,j+1)の係数 A ( k , get_k ( r_idx , z_idx - 1 )) = A ( k , get_k ( r_idx , z_idx - 1 )) + A2 ! f(i,j-1)の係数 else A ( k , k ) = A ( k , k ) + A0 A ( k , get_k ( r_idx + 1 , z_idx )) = A ( k , get_k ( r_idx + 1 , z_idx )) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( 1 , z_idx )) = A ( k , get_k ( 1 , z_idx )) + Am1 ! f(i-1,j)の係数 A ( k , get_k ( r_idx , z_idx + 1 )) = A ( k , get_k ( r_idx , z_idx + 1 )) + A2 ! f(i,j+1)の係数 A ( k , get_k ( r_idx , z_idx - 1 )) = A ( k , get_k ( r_idx , z_idx - 1 )) + A2 ! f(i,j-1)の係数 end if else if ( r_idx == Nr - 1 ) then if ( z_idx == 2 ) then A ( k , k ) = A ( k , k ) + A0 !A(k,get_k(r_idx+1,z_idx)) = A(k,get_k(r_idx+1,z_idx)) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( r_idx - 1 , z_idx )) = A ( k , get_k ( r_idx - 1 , z_idx )) + Am1 ! f(i-1,j)の係数 A ( k , get_k ( r_idx , z_idx + 1 )) = A ( k , get_k ( r_idx , z_idx + 1 )) + A2 ! f(i,j+1)の係数 !A(k,get_k(r_idx,z_idx-1)) = A(k,get_k(r_idx,z_idx-1)) + A2  ! f(i,j-1)の係数 else if ( z_idx == Nz - 1 ) then A ( k , k ) = A ( k , k ) + A0 !A(k,get_k(r_idx+1,z_idx)) = A(k,get_k(r_idx+1,z_idx)) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( r_idx - 1 , z_idx )) = A ( k , get_k ( r_idx - 1 , z_idx )) + Am1 ! f(i-1,j)の係数 !A(k,get_k(r_idx,z_idx+1)) = A(k,get_k(r_idx,z_idx+1)) + A2  ! f(i,j+1)の係数 A ( k , get_k ( r_idx , z_idx - 1 )) = A ( k , get_k ( r_idx , z_idx - 1 )) + A2 ! f(i,j-1)の係数 else A ( k , k ) = A ( k , k ) + A0 !A(k,get_k(r_idx+1,z_idx)) = A(k,get_k(r_idx+1,z_idx)) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( r_idx - 1 , z_idx )) = A ( k , get_k ( r_idx - 1 , z_idx )) + Am1 ! f(i-1,j)の係数 A ( k , get_k ( r_idx , z_idx + 1 )) = A ( k , get_k ( r_idx , z_idx + 1 )) + A2 ! f(i,j+1)の係数 A ( k , get_k ( r_idx , z_idx - 1 )) = A ( k , get_k ( r_idx , z_idx - 1 )) + A2 ! f(i,j-1)の係数 end if else if ( z_idx == 2 ) then A ( k , k ) = A ( k , k ) + A0 A ( k , get_k ( r_idx + 1 , z_idx )) = A ( k , get_k ( r_idx + 1 , z_idx )) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( r_idx - 1 , z_idx )) = A ( k , get_k ( r_idx - 1 , z_idx )) + Am1 ! f(i-1,j)の係数 A ( k , get_k ( r_idx , z_idx + 1 )) = A ( k , get_k ( r_idx , z_idx + 1 )) + A2 ! f(i,j+1)の係数 !A(k,get_k(r_idx,z_idx-1)) = A(k,get_k(r_idx,z_idx-1)) + A2  ! f(i,j-1)の係数 else if ( z_idx == Nz - 1 ) then A ( k , k ) = A ( k , k ) + A0 A ( k , get_k ( r_idx + 1 , z_idx )) = A ( k , get_k ( r_idx + 1 , z_idx )) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( r_idx - 1 , z_idx )) = A ( k , get_k ( r_idx - 1 , z_idx )) + Am1 ! f(i-1,j)の係数 !A(k,get_k(r_idx,z_idx+1)) = A(k,get_k(r_idx,z_idx+1)) + A2  ! f(i,j+1)の係数 A ( k , get_k ( r_idx , z_idx - 1 )) = A ( k , get_k ( r_idx , z_idx - 1 )) + A2 ! f(i,j-1)の係数 else A ( k , k ) = A ( k , k ) + A0 A ( k , get_k ( r_idx + 1 , z_idx )) = A ( k , get_k ( r_idx + 1 , z_idx )) + Ap1 ! f(i+1,j)の係数 A ( k , get_k ( r_idx - 1 , z_idx )) = A ( k , get_k ( r_idx - 1 , z_idx )) + Am1 ! f(i-1,j)の係数 A ( k , get_k ( r_idx , z_idx + 1 )) = A ( k , get_k ( r_idx , z_idx + 1 )) + A2 ! f(i,j+1)の係数 A ( k , get_k ( r_idx , z_idx - 1 )) = A ( k , get_k ( r_idx , z_idx - 1 )) + A2 ! f(i,j-1)の係数 end if end if end do !call write_mat(A(:,:),N) ! ディリクレ境界条件は、値が0なのでそのままでよく、r=1の条件は行列に反映されている b (:) = 0.0d0 ! ここでbを定義する do k = 1 , N r_idx = modulo ( k - 1 , Nr - 1 ) + 1 z_idx = ( k - 1 ) / ( Nr - 1 ) + 2 r = dble ( r_idx ) * dr b ( k ) = - 4 d0 * PI * e2 * rho_p ( r_idx , z_idx ) end do ! TODO: ここでAとbをDGESVに渡して解く end subroutine three_point_poisson_by_lapack subroutine write_mat ( A , N ) use , intrinsic :: iso_fortran_env real ( real64 ), intent ( in ) :: A (:,:) integer , intent ( in ) :: N integer ( int32 ) :: i , j write ( * , fmt = '(a)' ) \"Matrix A:\" do j = 1 , N do i = 1 , N write ( * , fmt = '(x,f8.3)' , advance = 'no' ) A ( j , i ) end do write ( * , * ) \"\" end do end subroutine write_mat function get_k ( r_idx , z_idx ) result ( k_idx ) use constants_and_parameters , only : Nr implicit none integer , intent ( in ) :: r_idx , z_idx integer :: k_idx k_idx = ( z_idx - 2 ) * ( Nr - 1 ) + r_idx end function get_k end module poisson_problem","tags":"","loc":"sourcefile/solve_poisson_problem.f90.html"},{"title":"main.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~main.f90->sourcefile~constants_and_parameters.f90 sourcefile~determine_meanfield_potential.f90 determine_meanfield_potential.f90 sourcefile~main.f90->sourcefile~determine_meanfield_potential.f90 sourcefile~determine_observables.f90 determine_observables.f90 sourcefile~main.f90->sourcefile~determine_observables.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~main.f90->sourcefile~global_variables.f90 sourcefile~harmonic_occ.f90 harmonic_occ.f90 sourcefile~main.f90->sourcefile~harmonic_occ.f90 sourcefile~math_derivation.f90 math_derivation.f90 sourcefile~main.f90->sourcefile~math_derivation.f90 sourcefile~math_integrate.f90 math_integrate.f90 sourcefile~main.f90->sourcefile~math_integrate.f90 sourcefile~write_to_file.f90 write_to_file.f90 sourcefile~main.f90->sourcefile~write_to_file.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~constants_and_parameters.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~global_variables.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~math_derivation.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~write_to_file.f90 sourcefile~solve_poisson_problem.f90 solve_poisson_problem.f90 sourcefile~determine_meanfield_potential.f90->sourcefile~solve_poisson_problem.f90 sourcefile~determine_observables.f90->sourcefile~constants_and_parameters.f90 sourcefile~determine_observables.f90->sourcefile~global_variables.f90 sourcefile~determine_observables.f90->sourcefile~math_integrate.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 sourcefile~harmonic_occ.f90->sourcefile~constants_and_parameters.f90 sourcefile~harmonic_occ.f90->sourcefile~global_variables.f90 sourcefile~spacial_function.f90 spacial_function.f90 sourcefile~harmonic_occ.f90->sourcefile~spacial_function.f90 sourcefile~math_derivation.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~constants_and_parameters.f90 sourcefile~math_integrate.f90->sourcefile~global_variables.f90 sourcefile~write_to_file.f90->sourcefile~constants_and_parameters.f90 sourcefile~write_to_file.f90->sourcefile~global_variables.f90 sourcefile~write_to_file.f90->sourcefile~math_integrate.f90 sourcefile~solve_poisson_problem.f90->sourcefile~constants_and_parameters.f90 sourcefile~solve_poisson_problem.f90->sourcefile~global_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Programs main Source Code main.f90 Source Code program main use , intrinsic :: iso_fortran_env , only : int32 use , intrinsic :: ieee_arithmetic , only : ieee_is_nan use :: write_to_file , only : outputsettings !フォルダ作成 use :: constants_and_parameters , only : foldername , max_iter , str_z implicit none integer ( int32 ) :: ti1 , tf1 , tr1 character ( 40 ) :: str integer ( int32 ) :: num_iter call system_clock ( ti1 ) call outputsettings call read_input_parameters call alloc_fields call initial_settings ! 波動関数の初期化，調和f振動子に基づく1粒子エネルギーを設定．ソートも行っている call calc_ground_state call dealloc_fields call system_clock ( tf1 , tr1 ) write ( str , '(i0)' ) int (( tf1 - ti1 ) / dble ( tr1 )) print * , \"実行時間は\" // trim ( str ) // \"秒\" print * , \"python3 ./../src/plotall.py \" // foldername // \" -z \" // trim ( str_z ) print * , \"endrecord\" contains subroutine is_converge_for_one_E ( is_converged ) use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : SD_eps , prev_eps , num_n , num_p , is_minus_var , is_coulomb & , is_update_coulomb , coulomb_updated_flag , cou_eps use math_integrate , only : volume_integrate use global_variables , only : one_E => prep_one_particle_E , one_E2 => prep_one_particle_E2 & , idx => prep_idx_array , Avarage_variance implicit none logical , intent ( out ) :: is_converged integer ( int32 ) :: k real ( real64 ) :: avg , E_Variance , tmp_var , one_e_diff , prev_e_sum , one_e_sum , diff_SD character ( 6 ) :: str_num write ( str_num , '(i6)' ) num_iter E_Variance = 0 d0 one_e_diff = 0 d0 do k = 1 , num_n one_e_sum = one_e_sum + one_e ( k , 1 ) end do do k = 1 , num_p one_e_sum = one_e_sum + one_e ( k , 2 ) end do one_e_diff = ( one_e_sum - prev_e_sum ) / dble ( num_n + num_p ) prev_e_sum = one_e_sum / dble ( num_n + num_p ) do k = 1 , num_n tmp_var = one_E2 ( idx ( k , 1 ), 1 ) - one_E ( idx ( k , 1 ), 1 ) ** 2 E_Variance = E_Variance + tmp_var if ( tmp_var < 0 ) then is_minus_var = . true . print * , tmp_var end if end do do k = 1 , num_p tmp_var = one_E2 ( idx ( k , 2 ), 2 ) - one_E ( idx ( k , 2 ), 2 ) ** 2 E_Variance = E_Variance + tmp_var if ( tmp_var < 0 ) then is_minus_var = . true . print * , tmp_var end if end do avg = E_Variance / dble ( num_n + num_p ) diff_SD = abs ( sqrt ( Avarage_variance ) - sqrt ( avg )) Avarage_variance = avg ! クーロンを更新するかどうかの判定 if ( ( is_coulomb . eqv . . true .) . and . ( modulo ( num_iter , 500 ) == 0 ) ) then is_update_coulomb = . true . print * , trim ( str_num ) // \"回目にクーロン力を更新．\" end if ! 収束判定 coulomb入れる場合は，アップデート後の分散がepsを下回っているかどうか if ( is_coulomb . eqv . . false .) then if ( diff_SD < SD_eps ) then is_converged = . true . end if else if ( diff_SD < SD_eps . and . one_e_diff < prev_eps ) then is_converged = . true . end if end if ! アップデートフラグをfalseにもどしておく．trueにするのはcoulombを更新したときのみ if ( coulomb_updated_flag ) then coulomb_updated_flag = . false . end if end subroutine is_converge_for_one_E subroutine calc_ground_state use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : max_iter , plot_iter , is_converged , is_minus_var use global_variables , only : Total_Energy , Avarage_variance use write_to_file , only : write_prep_sort & , write_wavefunction , write_d_wavefunction & , write_density_and_derivative , write_pot , write_meanfield_Energy & , write_iter_Energy implicit none character ( 40 ) :: str_iter , str_ave , str_time integer ( int32 ) :: num_write = 100 integer ( int32 ) :: write_iter = 1 integer ( int32 ) :: ti , tf , tr real ( real64 ) :: tmp_energy = 100000 d0 real ( real64 ) :: prev_var = 100000 d0 real ( real64 ) :: two_prev_var = 100000 d0 if ( num_write > max_iter ) then write_iter = max_iter / num_write end if call system_clock ( ti ) ! このdo文に入るときには既にidxはソート済み． ! 初期波動関数はinitial_settingsで調和振動子のエネルギーに基づいたソートを行っている ! IMAG_Evolutionのサブルーチンで「虚時間発展→前回の密度を使ってエネルギー計算→ソート→正規直交化」を行っている． do num_iter = 0 , max_iter if ( is_minus_var ) then print * , \"分散がゼロ以下になった．\" exit end if if ( ieee_is_nan ( Total_Energy )) then write ( * , * ) \"エネルギーがNan．\" exit end if if ( is_converged ) then write ( str , \"(f20.15)\" ) Total_Energy write ( str_iter , '(i0)' ) num_iter write ( * , * ) trim ( str_iter ) // \"回目でマイナス\" // trim ( str ) // \"MeVに収束した．\" exit end if if ( modulo ( num_iter , 500 ) == 0 . and . num_iter /= 0 ) then call system_clock ( tf , tr ) write ( str_time , '(i0)' ) int (( tf - ti ) / dble ( tr )) call system_clock ( ti ) write ( str_iter , '(i0)' ) num_iter write ( str_ave , \"(f20.15)\" ) Avarage_variance ! char型変数の長さも考慮しないといけない write ( * , * ) trim ( str_iter ) // \"回目の計算で分散は\" // trim ( str_ave ) // \"MeV& 前回から\" // trim ( str_time ) // \"秒かかった．\" !if(prev_var < Avarage_variance .and. two_prev_var < prev_var)then !    write(*,*) \"分散が増えた．\" !    exit !end if two_prev_var = prev_var prev_var = Avarage_variance end if tmp_energy = Total_Energy call calc_derivation_of_wavefunction ! prep_**配列の計算 call copy_to_occupied_wf ! 更新されているidxを使って占有軌道の配列にコピー call calc_densities ! 密度の計算 call calc_meanfield ! 占有軌道を使って平均場を計算 call calc_observables ! 密度で決定される物理量を計算（Skyrmeエネルギーや四重極モーメントなど） if ( modulo ( num_iter , write_iter ) == 0 ) then call write_prep_sort ( num_iter ) call write_iter_Energy ( num_iter ) call write_meanfield_Energy ( num_iter ) ! write meanfield energy end if if ( modulo ( num_iter , plot_iter ) == 0 . or . num_iter == 0 . or . num_iter == max_iter ) then call write_wavefunction ( num_iter ) ! 波動関数の書き出し call write_d_wavefunction ( num_iter ) ! 波動関数の微分の書き出し call write_density_and_derivative ( num_iter ) ! 密度とその微分の書き出し call write_pot ( num_iter ) ! 平均場の書き出し print * , \"．重心の位置は\" // trim ( str_z ) // \"fm\" print * , \"python3 ./../src/plotall.py \" // foldername // \" -z \" // trim ( str_z ) end if call calc_hf_by_imaginary_time_evolution ! 虚時間発展，波動関数の更新，エネルギーの計算，idxソート，正規直交化 end do write ( str , \"(f20.15)\" ) Total_Energy if ( is_converged . eqv . . false .) then if ( Total_Energy > 0 ) then print * , \"収束しなかった．エネルギーは\" // trim ( str ) // \"MeV\" else print * , \"収束しなかった．エネルギーは\" // trim ( str ) // \"MeV．\" end if end if call write_wavefunction ( num_iter ) ! 波動関数の書き出し call write_d_wavefunction ( num_iter ) ! 波動関数の微分の書き出し call write_density_and_derivative ( num_iter ) ! 密度とその微分の書き出し call write_pot ( num_iter ) ! 平均場の書き出し end subroutine calc_ground_state subroutine calc_densities implicit none call calc_density_and_lap ! ρとΔρの計算 call calc_kinetic_density ! τの計算 call calc_spin_orbit_density_and_div ! JとdivJの計算 end subroutine calc_densities subroutine calc_observables use determine_observables implicit none call calc_Skyrme_Energy_by_integrate call calc_Kinetic_Energy_by_integrate call calc_CM_Energy call calc_Coulomb_Energy call calc_Total_Energy end subroutine calc_observables subroutine read_input_parameters use , intrinsic :: iso_fortran_env , only : int32 use global_variables use constants_and_parameters implicit none integer ( int32 ) :: fi , is character ( 4 ) :: str namelist / nuclear_param / num_n , num_p , prep_max_r , prep_max_z , prep_max_m , nuc_name namelist / calc_param / max_iter , lagrange_multiplier , imaginary_time_step , cou_eps , SD_eps , prev_eps & , is_use_dd , is_output , not_divJ , is_use_B , is_use_W & , is_TimeR , is_coulomb , is_use_second_imag , Nr , Nz , plot_iter open ( unit = fi , file = \"./../src/input_parameters.txt\" , status = \"old\" , iostat = is ) read ( fi , nuclear_param , iostat = is ) if ( is /= 0 ) stop \"Error reading nuclear_param.\" read ( fi , calc_param , iostat = is ) if ( is /= 0 ) stop \"Error reading calc_param.\" close ( fi ) prep_number = ( prep_max_r + 1 ) * ( prep_max_z + 1 ) * ( 2 * prep_max_m + 1 ) write ( str , '(i4)' ) prep_number print * , \"計算する軌道の数は\" // trim ( str ) // \"個\" if ( prep_number < max ( num_n , num_p )) then write ( * , * ) \"Error: prep_number must be larger than max(num_n,num_p).\" stop end if dr = r_max / dble ( Nr ) ! [fm] The grid spacing in r-direction dz = z_max / dble ( Nz ) ! [fm] The grid spacing in z-direction ! is_memoを用意して，readしてターミナルから文字列を受け取るようにしてメモを付ける end subroutine read_input_parameters subroutine initial_settings use , intrinsic :: iso_fortran_env , only : int32 use global_variables , only : r_vec , z_vec , dr , dz , Nr , Nz , z_max , is_TimeR implicit none integer ( int32 ) :: i ! 格子点の位置を決める．特異点を回避するためにrはdr/2だけずらしている． do i = 1 , Nr r_vec ( i ) = dr * dble ( i ) - dr / 2.0d0 end do do i = 1 , Nz z_vec ( i ) = dz * dble ( i ) end do if ( is_TimeR ) then call prep_time_reversal_wavefunction else call prep_initial_wavefunction end if end subroutine initial_settings subroutine prep_time_reversal_wavefunction ! 規格化はできている（overlap(k,k)=1） use , intrinsic :: iso_fortran_env , only : int32 , real64 use global_variables , only : prep_wf_plus , prep_wf_minus , r_vec , z_vec , z_max & , prep_max_r , prep_max_z , prep_max_m & , prep_mag => prep_magnetic_q_num , prep_idx_array & , prep_E => prep_one_particle_E use constants_and_parameters , only : betain => deformation_degree , z_center , prep_number , Nr , Nz , nuc_name & , prep_max_m , prep_max_r , prep_max_z use harmonic_occ_wf , only : set_harmonic_occ , calc_occ_energy use math_integrate , only : volume_integrate implicit none integer ( int32 ) :: i , j , k , np , tmp integer ( int32 ) :: prep_r , prep_z , prep_m integer ( int32 ), allocatable :: rzm_ar (:,:) integer ( int32 ) :: prep real ( real64 ) :: z0 ! 原子核の中心（0, z_max/2） allocate ( rzm_ar ( prep_number , 3 )) z0 = z_center ! 取りうる量子数の設定 prep = 1 do k =- prep_max_m , prep_max_m do i = 0 , prep_max_r do j = 0 , prep_max_z rzm_ar ( prep , 1 ) = i rzm_ar ( prep , 2 ) = j rzm_ar ( prep , 3 ) = k prep_idx_array ( prep , 1 ) = prep prep_idx_array ( prep , 2 ) = prep prep = prep + 1 end do end do end do ! Time-reversalを課して方位量子数を設定，配列も直す do np = 1 , 2 do prep = 1 , prep_number , 2 prep_mag ( prep , np ) = rzm_ar ( prep , 3 ) prep_mag ( prep + 1 , np ) = - prep_mag ( prep , np ) - 1 ! time-reversal rzm_ar ( prep + 1 , 3 ) = - prep_mag ( prep , np ) - 1 ! time-reversal end do end do do np = 1 , 2 do prep = 1 , prep_number , 2 do j = 1 , Nz do i = 1 , Nr prep_wf_plus ( i , j , prep , np ) & = set_harmonic_occ ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ), r_vec ( i ), z_vec ( j ) - z0 , betain ) / sqrt ( 2 d0 ) prep_wf_minus ( i , j , prep , np ) & = set_harmonic_occ ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ) + 1 , r_vec ( i ), z_vec ( j ) - z0 , betain ) / sqrt ( 2 d0 ) prep_wf_plus ( i , j , prep + 1 , np ) = - prep_wf_minus ( i , j , prep , np ) ! time-reversal prep_wf_minus ( i , j , prep + 1 , np ) = prep_wf_plus ( i , j , prep , np ) ! time-reversal end do end do end do end do do np = 1 , 2 do prep = 1 , prep_number prep_E ( prep , np ) = calc_occ_energy ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ), betain ) end do end do ! エネルギーの小さい順にソート call sort_energy_and_idx ( prep_E (:,:), prep_idx_array (:,:)) end subroutine prep_time_reversal_wavefunction ! 波動関数の初期化，調和振動子に基づく1粒子エネルギーを設定 subroutine prep_initial_wavefunction ! 規格化はできている（overlap(k,k)=1） use , intrinsic :: iso_fortran_env , only : int32 , real64 use global_variables , only : prep_wf_plus , prep_wf_minus , r_vec , z_vec , z_max & , prep_max_r , prep_max_z , prep_max_m & , prep_mag => prep_magnetic_q_num , prep_idx_array & , prep_E => prep_one_particle_E , init_rzm_to_write use constants_and_parameters , only : betain => deformation_degree , z_center , prep_number , Nr , Nz & , prep_max_m , prep_max_r , prep_max_z use harmonic_occ_wf , only : set_harmonic_occ , calc_occ_energy use math_integrate , only : volume_integrate implicit none integer ( int32 ) :: i , j , k , np integer ( int32 ), allocatable :: rzm_ar (:,:) integer ( int32 ) :: prep real ( real64 ) :: z0 ! 原子核の中心（0, z_max/2） character ( 1 ) :: str_r character ( 1 ) :: str_z character ( 2 ) :: str_m allocate ( rzm_ar ( prep_number , 3 )) z0 = z_center !!!!!!--------- prep_numberも変更してます -----------！！！！！！！！！！！ ! 取りうる量子数の設定 prep = 1 do k =- prep_max_m , prep_max_m do i = 0 , prep_max_r do j = 0 , prep_max_z rzm_ar ( prep , 1 ) = i rzm_ar ( prep , 2 ) = j rzm_ar ( prep , 3 ) = k prep_idx_array ( prep , 1 ) = prep prep_idx_array ( prep , 2 ) = prep write ( str_r , '(i1)' ) i write ( str_z , \"(i1)\" ) j write ( str_m , \"(i2)\" ) k init_rzm_to_write ( prep ) = str_r // str_z // str_m prep = prep + 1 end do end do end do do np = 1 , 2 do prep = 1 , prep_number prep_mag ( prep , np ) = rzm_ar ( prep , 3 ) end do end do do np = 1 , 2 do prep = 1 , prep_number do j = 1 , Nz do i = 1 , Nr prep_wf_plus ( i , j , prep , np ) & = set_harmonic_occ ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ), r_vec ( i ), z_vec ( j ) - z0 , betain ) / sqrt ( 2 d0 ) prep_wf_minus ( i , j , prep , np ) & = set_harmonic_occ ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ) + 1 , r_vec ( i ), z_vec ( j ) - z0 , betain ) / sqrt ( 2 d0 ) end do end do end do end do do np = 1 , 2 do prep = 1 , prep_number prep_E ( prep , np ) = calc_occ_energy ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ), betain ) end do end do do np = 1 , 2 do prep = 1 , prep_number do j = 1 , Nz do i = 1 , Nr prep_wf_plus ( i , j , prep , np ) & = set_harmonic_occ ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ), r_vec ( i ), z_vec ( j ) - z0 , betain ) / sqrt ( 2 d0 ) prep_wf_minus ( i , j , prep , np ) & = set_harmonic_occ ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ) + 1 , r_vec ( i ), z_vec ( j ) - z0 , betain ) / sqrt ( 2 d0 ) end do end do end do end do do np = 1 , 2 do prep = 1 , prep_number prep_E ( prep , np ) = calc_occ_energy ( rzm_ar ( prep , 1 ), rzm_ar ( prep , 2 ), prep_mag ( prep , np ), betain ) end do end do ! エネルギーの小さい順にソート call sort_energy_and_idx ( prep_E (:,:), prep_idx_array (:,:)) end subroutine prep_initial_wavefunction subroutine calc_derivation_of_wavefunction use :: constants_and_parameters use :: math_derivation , only : math_diff_r_9point , math_diff_z_9point , math_diff_2r_9point , math_diff_2z_9point use :: global_variables , only : prep_wf_plus , prep_wf_minus & , prep_dr_wf_plus , prep_dr_wf_minus , prep_dz_wf_plus , prep_dz_wf_minus & , prep_ddr_wf_plus , prep_ddr_wf_minus , prep_ddz_wf_plus , prep_ddz_wf_minus & , prep_lap_wf_plus , prep_lap_wf_minus & , r_vec , prep_mag => prep_magnetic_q_num & , prep_SDNWP , prep_SDNWM implicit none integer ( int32 ) :: prep , i , j , l do l = 1 , 2 do prep = 1 , prep_number prep_dr_wf_plus (:,:, prep , l ) = math_diff_r_9point ( f = prep_wf_plus (:,:, prep , l )) prep_dz_wf_plus (:,:, prep , l ) = math_diff_z_9point ( f = prep_wf_plus (:,:, prep , l )) if ( is_use_dd ) then prep_ddr_wf_plus (:,:, prep , l ) = math_diff_2r_9point ( f = prep_wf_plus (:,:, prep , l )) prep_ddz_wf_plus (:,:, prep , l ) = math_diff_2z_9point ( f = prep_wf_plus (:,:, prep , l )) else prep_ddr_wf_plus (:,:, prep , l ) = math_diff_r_9point ( f = prep_dr_wf_plus (:,:, prep , l )) prep_ddz_wf_plus (:,:, prep , l ) = math_diff_z_9point ( f = prep_dz_wf_plus (:,:, prep , l )) end if prep_dr_wf_minus (:,:, prep , l ) = math_diff_r_9point ( f = prep_wf_minus (:,:, prep , l )) prep_dz_wf_minus (:,:, prep , l ) = math_diff_z_9point ( f = prep_wf_minus (:,:, prep , l )) if ( is_use_dd ) then prep_ddr_wf_minus (:,:, prep , l ) = math_diff_2r_9point ( f = prep_wf_minus (:,:, prep , l )) prep_ddz_wf_minus (:,:, prep , l ) = math_diff_2z_9point ( f = prep_wf_minus (:,:, prep , l )) else prep_ddr_wf_minus (:,:, prep , l ) = math_diff_r_9point ( f = prep_dr_wf_minus (:,:, prep , l )) prep_ddz_wf_minus (:,:, prep , l ) = math_diff_z_9point ( f = prep_dz_wf_minus (:,:, prep , l )) end if end do end do ! calculation laplacian of wavefunction ! ddf + df/r + ddz - (m/r)&#94;2 f do l = 1 , 2 do prep = 1 , prep_number do j = 1 , Nz do i = 1 , Nr prep_lap_wf_plus ( i , j , prep , l ) = prep_ddr_wf_plus ( i , j , prep , l ) + prep_dr_wf_plus ( i , j , prep , l ) / r_vec ( i ) & + prep_ddz_wf_plus ( i , j , prep , l ) - ( dble ( prep_mag ( prep , l )) / r_vec ( i )) ** 2 * prep_wf_plus ( i , j , prep , l ) prep_lap_wf_minus ( i , j , prep , l ) = prep_ddr_wf_minus ( i , j , prep , l ) + prep_dr_wf_minus ( i , j , prep , l ) / r_vec ( i )& + prep_ddz_wf_minus ( i , j , prep , l ) - ( dble ( prep_mag ( prep , l ) + 1 ) / r_vec ( i )) ** 2 * prep_wf_minus ( i , j , prep , l ) end do end do end do end do ! caluculation sigma dot nabla of wavefunction do l = 1 , 2 do prep = 1 , prep_number do j = 1 , Nz do i = 1 , Nr prep_SDNWP ( i , j , prep , l ) = prep_dz_wf_plus ( i , j , prep , l ) + prep_dr_wf_minus ( i , j , prep , l ) & + dble ( prep_mag ( prep , l ) + 1 ) / r_vec ( i ) * prep_wf_minus ( i , j , prep , l ) prep_SDNWM ( i , j , prep , l ) = - prep_dz_wf_minus ( i , j , prep , l ) + prep_dr_wf_plus ( i , j , prep , l ) & - dble ( prep_mag ( prep , l )) / r_vec ( i ) * prep_wf_plus ( i , j , prep , l ) end do end do end do end do !print*, \"prep_SDNWP(i,j,prep,l) = \",maxval(prep_dz_wf_plus), maxval(prep_dr_wf_minus)!, & !!maxval(dble(prep_mag(prep,l)+1)/r_vec(i)*prep_wf_minus) !print*, \"prep_SDNWM(i,j,prep,l) = \",maxval(prep_dz_wf_minus), maxval(prep_dr_wf_plus)!, & !!maxval(-dble(prep_mag(prep,l))/r_vec(i)*prep_wf_plus) end subroutine calc_derivation_of_wavefunction subroutine copy_to_occupied_wf use :: constants_and_parameters , betain => deformation_degree use :: math_derivation , only : math_diff_r_9point , math_diff_z_9point , math_diff_2r_9point , math_diff_2z_9point use :: global_variables , only : wf_plus , wf_minus , dr_wf_plus & , dr_wf_minus , dz_wf_plus , dz_wf_minus & , ddr_wf_plus , ddr_wf_minus , ddz_wf_plus , ddz_wf_minus & , lap_wf_plus , lap_wf_minus & , prep_wf_plus , prep_wf_minus & , prep_dr_wf_plus , prep_dr_wf_minus , prep_dz_wf_plus , prep_dz_wf_minus & , prep_ddr_wf_plus , prep_ddr_wf_minus , prep_ddz_wf_plus , prep_ddz_wf_minus & , prep_lap_wf_plus , prep_lap_wf_minus & , prep_mag => prep_magnetic_q_num , mag => magnetic_q_num , prep_idx_array & , prep_SDNWP , prep_SDNWM , SDNWP , SDNWM implicit none integer ( int32 ) :: k , kp !波動関数のコピー do k = 1 , num_n mag ( k ) = prep_mag ( prep_idx_array ( k , 1 ), 1 ) wf_plus (:,:, k ) = prep_wf_plus (:,:, prep_idx_array ( k , 1 ), 1 ) wf_minus (:,:, k ) = prep_wf_minus (:,:, prep_idx_array ( k , 1 ), 1 ) end do do k = 1 , num_p kp = k + num_n mag ( kp ) = prep_mag ( prep_idx_array ( k , 2 ), 2 ) wf_plus (:,:, kp ) = prep_wf_plus (:,:, prep_idx_array ( k , 2 ), 2 ) wf_minus (:,:, kp ) = prep_wf_minus (:,:, prep_idx_array ( k , 2 ), 2 ) end do ! 導関数とかのコピー do k = 1 , num_n dr_wf_plus (:,:, k ) = prep_dr_wf_plus (:,:, prep_idx_array ( k , 1 ), 1 ) dz_wf_plus (:,:, k ) = prep_dz_wf_plus (:,:, prep_idx_array ( k , 1 ), 1 ) dr_wf_minus (:,:, k ) = prep_dr_wf_minus (:,:, prep_idx_array ( k , 1 ), 1 ) dz_wf_minus (:,:, k ) = prep_dz_wf_minus (:,:, prep_idx_array ( k , 1 ), 1 ) ddr_wf_plus (:,:, k ) = prep_ddr_wf_plus (:,:, prep_idx_array ( k , 1 ), 1 ) ddz_wf_plus (:,:, k ) = prep_ddz_wf_plus (:,:, prep_idx_array ( k , 1 ), 1 ) ddr_wf_minus (:,:, k ) = prep_ddr_wf_minus (:,:, prep_idx_array ( k , 1 ), 1 ) ddz_wf_minus (:,:, k ) = prep_ddz_wf_minus (:,:, prep_idx_array ( k , 1 ), 1 ) lap_wf_plus (:,:, k ) = prep_lap_wf_plus (:,:, prep_idx_array ( k , 1 ), 1 ) lap_wf_minus (:,:, k ) = prep_lap_wf_minus (:,:, prep_idx_array ( k , 1 ), 1 ) SDNWP (:,:, k ) = prep_SDNWP (:,:, prep_idx_array ( k , 1 ), 1 ) SDNWM (:,:, k ) = prep_SDNWM (:,:, prep_idx_array ( k , 1 ), 1 ) end do do k = 1 , num_p kp = k + num_n dr_wf_plus (:,:, kp ) = prep_dr_wf_plus (:,:, prep_idx_array ( k , 2 ), 2 ) dz_wf_plus (:,:, kp ) = prep_dz_wf_plus (:,:, prep_idx_array ( k , 2 ), 2 ) dr_wf_minus (:,:, kp ) = prep_dr_wf_minus (:,:, prep_idx_array ( k , 2 ), 2 ) dz_wf_minus (:,:, kp ) = prep_dz_wf_minus (:,:, prep_idx_array ( k , 2 ), 2 ) ddr_wf_plus (:,:, kp ) = prep_ddr_wf_plus (:,:, prep_idx_array ( k , 2 ), 2 ) ddz_wf_plus (:,:, kp ) = prep_ddz_wf_plus (:,:, prep_idx_array ( k , 2 ), 2 ) ddr_wf_minus (:,:, kp ) = prep_ddr_wf_minus (:,:, prep_idx_array ( k , 2 ), 2 ) ddz_wf_minus (:,:, kp ) = prep_ddz_wf_minus (:,:, prep_idx_array ( k , 2 ), 2 ) lap_wf_plus (:,:, kp ) = prep_lap_wf_plus (:,:, prep_idx_array ( k , 2 ), 2 ) lap_wf_minus (:,:, kp ) = prep_lap_wf_minus (:,:, prep_idx_array ( k , 2 ), 2 ) SDNWP (:,:, kp ) = prep_SDNWP (:,:, prep_idx_array ( k , 2 ), 2 ) SDNWM (:,:, kp ) = prep_SDNWM (:,:, prep_idx_array ( k , 2 ), 2 ) end do end subroutine copy_to_occupied_wf subroutine sort_energy_and_idx ( energy_array , idx ) use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none real ( real64 ), intent ( inout ) :: energy_array (:,:) integer ( int32 ), intent ( inout ) :: idx (:,:) integer ( int32 ) :: i , j , N , l real ( real64 ) :: tmp_energy real ( real64 ) :: eps integer ( int32 ) :: tmp_idx logical , save :: is_first = . true . if ( size ( energy_array , 2 ) /= 2 . or . size ( idx , 2 ) /= 2 ) then write ( * , * ) \"Error: array (dim2) must be 2.\" stop end if !stop \"adawdas\" eps = 0 d0 N = size ( energy_array , 1 ) if ( size ( idx , 1 ) /= N ) then write ( * , * ) \"Error: array (dim1) must be same.\" stop end if ! インデックスの順番を整える（前回の結果が保存されているため初期化する） idx (:, 1 ) = [( i , i = 1 , N )] idx (:, 2 ) = [( i , i = 1 , N )] do l = 1 , 2 do i = 1 , N - 1 do j = i + 1 , N if ( energy_array ( i , l ) > energy_array ( j , l ) + eps ) then !print*, tmp_energy !stop tmp_energy = energy_array ( i , l ) tmp_idx = idx ( i , l ) energy_array ( i , l ) = energy_array ( j , l ) idx ( i , l ) = idx ( j , l ) energy_array ( j , l ) = tmp_energy idx ( j , l ) = tmp_idx end if end do end do end do !if(is_first)then !    is_first = .false. !else !print*, \"energy_array = \",energy_array(:,1) !print*, \"idx = \",idx(:,1) !stop \"return sort energy_and_idx\" !end if end subroutine sort_energy_and_idx subroutine calc_meanfield use determine_meanfield_potential , only : calc_pot_U , calc_pot_B , calc_pot_W implicit none call calc_pot_U ! 今はWood-Saxon型 call calc_pot_B call calc_pot_W end subroutine calc_meanfield subroutine calc_hf_by_imaginary_time_evolution use constants_and_parameters , only : is_converged , is_minus_var use global_variables , only : prep_E => prep_one_particle_E , prep_idx_array implicit none call calc_Hpsi call calc_one_particle_energy call calc_Hpsi2 ! calc  h&#94;2|wf> call is_converge_for_one_E ( is_converged ) if ( is_minus_var . neqv . . true .) then call calc_IMAG_Evolution ( 1 ) call calc_IMAG_Evolution ( 2 ) call calc_Hpsi call calc_one_particle_energy call sort_energy_and_idx ( prep_E (:,:), prep_idx_array (:,:)) call Schmidt_orthogonalization ( 1 ) call Schmidt_orthogonalization ( 2 ) end if end subroutine calc_hf_by_imaginary_time_evolution subroutine calc_Hpsi2 use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : HBAR2_over_2m , Nr , Nz , is_use_B , is_use_W use math_derivation , only : math_diff_r_9point , math_diff_z_9point , math_diff_2r_9point , math_diff_2z_9point use global_variables , only : prep_number & , prep_Hpsi2_minus , prep_Hpsi2_plus & , prep_Hpsi_plus , prep_Hpsi_minus , U_n , B_n , W_n , U_p , B_p , W_p & , r_vec , prep_mag => prep_magnetic_q_num integer ( int32 ) :: prep , l , i , j real ( real64 ), allocatable :: tmp_UHpsi_plus (:,:,:,:), tmp_UHpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_BHpsi_plus (:,:,:,:), tmp_BHpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_WHpsi_plus (:,:,:,:), tmp_WHpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_lap_Hpsi_plus (:,:,:,:), tmp_lap_Hpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_dr_Hpsi_plus (:,:,:,:), tmp_dr_Hpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_dz_Hpsi_plus (:,:,:,:), tmp_dz_Hpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_ddr_Hpsi_plus (:,:,:,:), tmp_ddr_Hpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_ddz_Hpsi_plus (:,:,:,:), tmp_ddz_Hpsi_minus (:,:,:,:) real ( real64 ), allocatable :: tmp_SDNHWP (:,:,:,:), tmp_SDNHWM (:,:,:,:) real ( real64 ), allocatable :: dr_B (:,:), dz_B (:,:) allocate ( tmp_UHpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_UHpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_BHpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_BHpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_WHpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_WHpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_lap_Hpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_lap_Hpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_dr_Hpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_dr_Hpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_dz_Hpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_dz_Hpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_ddr_Hpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_ddr_Hpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_ddz_Hpsi_plus , mold = prep_Hpsi_plus ) allocate ( tmp_ddz_Hpsi_minus , mold = prep_Hpsi_minus ) allocate ( tmp_SDNHWP ( Nr , Nz , prep_number , 2 ) ) ! [fm&#94;-3/2]  (r,z,nucleon) allocate ( tmp_SDNHWM ( Nr , Nz , prep_number , 2 ) ) ! [fm&#94;-3/2]  (r,z,nucleon) allocate ( dr_B ( Nr , Nz )) allocate ( dz_B ( Nr , Nz )) do prep = 1 , prep_number tmp_UHpsi_plus (:,:, prep , 1 ) = U_n (:,:) * prep_Hpsi_plus (:,:, prep , 1 ) tmp_UHpsi_minus (:,:, prep , 1 ) = U_n (:,:) * prep_Hpsi_minus (:,:, prep , 1 ) tmp_UHpsi_plus (:,:, prep , 2 ) = U_p (:,:) * prep_Hpsi_plus (:,:, prep , 2 ) tmp_UHpsi_minus (:,:, prep , 2 ) = U_p (:,:) * prep_Hpsi_minus (:,:, prep , 2 ) end do dr_B (:,:) = math_diff_r_9point ( B_n (:,:)) dz_B (:,:) = math_diff_z_9point ( B_n (:,:)) do l = 1 , 2 do prep = 1 , prep_number tmp_dr_Hpsi_plus (:,:, prep , l ) = math_diff_r_9point ( f = prep_Hpsi_plus (:,:, prep , l )) tmp_dz_Hpsi_plus (:,:, prep , l ) = math_diff_z_9point ( f = prep_Hpsi_plus (:,:, prep , l )) tmp_ddr_Hpsi_plus (:,:, prep , l ) = math_diff_2r_9point ( f = prep_Hpsi_plus (:,:, prep , l )) tmp_ddz_Hpsi_plus (:,:, prep , l ) = math_diff_2z_9point ( f = prep_Hpsi_plus (:,:, prep , l )) tmp_dr_Hpsi_minus (:,:, prep , l ) = math_diff_r_9point ( f = prep_Hpsi_minus (:,:, prep , l )) tmp_dz_Hpsi_minus (:,:, prep , l ) = math_diff_z_9point ( f = prep_Hpsi_minus (:,:, prep , l )) tmp_ddr_Hpsi_minus (:,:, prep , l ) = math_diff_2r_9point ( f = prep_Hpsi_minus (:,:, prep , l )) tmp_ddz_Hpsi_minus (:,:, prep , l ) = math_diff_2z_9point ( f = prep_Hpsi_minus (:,:, prep , l )) end do end do do l = 1 , 2 do prep = 1 , prep_number do j = 1 , Nz do i = 1 , Nr tmp_lap_Hpsi_plus ( i , j , prep , l ) = tmp_ddr_Hpsi_plus ( i , j , prep , l ) + tmp_dr_Hpsi_plus ( i , j , prep , l ) / r_vec ( i ) & + tmp_ddz_Hpsi_plus ( i , j , prep , l ) - ( dble ( prep_mag ( prep , l )) / r_vec ( i )) ** 2 * prep_Hpsi_plus ( i , j , prep , l ) tmp_lap_Hpsi_minus ( i , j , prep , l ) = tmp_ddr_Hpsi_minus ( i , j , prep , l ) + tmp_dr_Hpsi_minus ( i , j , prep , l ) / r_vec ( i )& + tmp_ddz_Hpsi_minus ( i , j , prep , l ) - ( dble ( prep_mag ( prep , l ) + 1 ) / r_vec ( i )) ** 2 * prep_Hpsi_minus ( i , j , prep , l ) end do end do end do end do do prep = 1 , prep_number tmp_BHpsi_plus (:,:, prep , 1 ) = B_n (:,:) * tmp_lap_Hpsi_plus (:,:, prep , 1 ) & + dr_B (:,:) * tmp_dr_Hpsi_plus (:,:, prep , 1 ) & + dz_B (:,:) * tmp_dz_Hpsi_plus (:,:, prep , 1 ) tmp_BHpsi_minus (:,:, prep , 1 ) = B_n (:,:) * tmp_lap_Hpsi_minus (:,:, prep , 1 ) & + dr_B (:,:) * tmp_dr_Hpsi_minus (:,:, prep , 1 ) & + dz_B (:,:) * tmp_dz_Hpsi_minus (:,:, prep , 1 ) end do dr_B (:,:) = math_diff_r_9point ( B_p (:,:)) dz_B (:,:) = math_diff_z_9point ( B_p (:,:)) do prep = 1 , prep_number tmp_BHpsi_plus (:,:, prep , 2 ) = B_p (:,:) * tmp_lap_Hpsi_plus (:,:, prep , 2 ) & + dr_B (:,:) * tmp_dr_Hpsi_plus (:,:, prep , 2 ) & + dz_B (:,:) * tmp_dz_Hpsi_plus (:,:, prep , 2 ) tmp_BHpsi_minus (:,:, prep , 2 ) = B_p (:,:) * tmp_lap_Hpsi_minus (:,:, prep , 2 ) & + dr_B (:,:) * tmp_dr_Hpsi_minus (:,:, prep , 2 ) & + dz_B (:,:) * tmp_dz_Hpsi_minus (:,:, prep , 2 ) end do do l = 1 , 2 do prep = 1 , prep_number do j = 1 , Nz do i = 1 , Nr tmp_SDNHWP ( i , j , prep , l ) = tmp_dz_Hpsi_plus ( i , j , prep , l ) + tmp_dr_Hpsi_minus ( i , j , prep , l ) & + dble ( prep_mag ( prep , l ) + 1 ) / r_vec ( i ) * prep_Hpsi_minus ( i , j , prep , l ) tmp_SDNHWM ( i , j , prep , l ) = - tmp_dz_Hpsi_minus ( i , j , prep , l ) + tmp_dr_Hpsi_plus ( i , j , prep , l ) & - dble ( prep_mag ( prep , l )) / r_vec ( i ) * prep_Hpsi_plus ( i , j , prep , l ) end do end do end do end do do prep = 1 , prep_number tmp_WHpsi_plus (:,:, prep , 1 ) = W_n (:,:, 3 ) * ( tmp_SDNHWP (:,:, prep , 1 ) - tmp_dz_Hpsi_plus (:,:, prep , 1 )) & + W_n (:,:, 1 ) * ( tmp_SDNHWM (:,:, prep , 1 ) - tmp_dr_Hpsi_plus (:,:, prep , 1 )) tmp_WHpsi_minus (:,:, prep , 1 ) = W_n (:,:, 1 ) * ( tmp_SDNHWP (:,:, prep , 1 ) - tmp_dr_Hpsi_minus (:,:, prep , 1 )) & - W_n (:,:, 3 ) * ( tmp_SDNHWM (:,:, prep , 1 ) + tmp_dz_Hpsi_minus (:,:, prep , 1 )) tmp_WHpsi_plus (:,:, prep , 2 ) = W_p (:,:, 3 ) * ( tmp_SDNHWP (:,:, prep , 2 ) - tmp_dz_Hpsi_plus (:,:, prep , 2 )) & + W_p (:,:, 1 ) * ( tmp_SDNHWM (:,:, prep , 2 ) - tmp_dr_Hpsi_plus (:,:, prep , 2 )) tmp_WHpsi_minus (:,:, prep , 2 ) = W_p (:,:, 1 ) * ( tmp_SDNHWP (:,:, prep , 2 ) - tmp_dr_Hpsi_minus (:,:, prep , 2 )) & - W_p (:,:, 3 ) * ( tmp_SDNHWM (:,:, prep , 2 ) + tmp_dz_Hpsi_minus (:,:, prep , 2 )) end do prep_Hpsi2_plus (:,:,:,:) = tmp_UHpsi_plus (:,:,:,:) - HBAR2_over_2m * tmp_lap_Hpsi_plus (:,:,:,:) prep_Hpsi2_minus (:,:,:,:) = tmp_UHpsi_minus (:,:,:,:) - HBAR2_over_2m * tmp_lap_Hpsi_minus (:,:,:,:) ! Bpsiには，密度依存部分のみを含めている． if ( is_use_B ) then prep_Hpsi2_plus (:,:,:,:) = prep_Hpsi2_plus (:,:,:,:) - tmp_BHpsi_plus (:,:,:,:) prep_Hpsi2_minus (:,:,:,:) = prep_Hpsi2_minus (:,:,:,:) - tmp_BHpsi_minus (:,:,:,:) end if ! BHpsiはマイナスでたさないといけない if ( is_use_W ) then prep_Hpsi2_plus (:,:,:,:) = prep_Hpsi2_plus (:,:,:,:) + tmp_WHpsi_plus (:,:,:,:) prep_Hpsi2_minus (:,:,:,:) = prep_Hpsi2_minus (:,:,:,:) + tmp_WHpsi_minus (:,:,:,:) end if end subroutine calc_Hpsi2 subroutine calc_one_particle_energy use , intrinsic :: iso_fortran_env , only : int32 use constants_and_parameters , only : prep_number , HBAR2_over_2m use math_integrate , only : volume_integrate use global_variables , only : prep_wf_plus , prep_wf_minus & , prep_Upsi_plus , prep_Upsi_minus , prep_Bpsi_plus , prep_Bpsi_minus , prep_Wpsi_plus , prep_Wpsi_minus & , prep_E => prep_one_particle_E , prep_E_U => prep_one_E_U , prep_E_Kin => prep_one_E_Kin & , prep_E_B => prep_one_E_B , prep_E_W => prep_one_E_W & , prep_lap_wf_plus , prep_lap_wf_minus , prep_Hpsi_plus , prep_Hpsi_minus , prep_one_particle_E2 implicit none integer ( int32 ) :: prep , np ! 引数は  prep_E_U(prep,np,ud)である． do np = 1 , 2 do prep = 1 , prep_number prep_E_U ( prep , np , 1 ) = volume_integrate ( f = prep_wf_plus (:,:, prep , np ) * prep_Upsi_plus (:,:, prep , np )) prep_E_U ( prep , np , 2 ) = volume_integrate ( f = prep_wf_minus (:,:, prep , np ) * prep_Upsi_minus (:,:, prep , np )) prep_E_Kin ( prep , np , 1 ) = volume_integrate ( f = prep_wf_plus (:,:, prep , np )& * ( - 1 d0 * HBAR2_over_2m * prep_lap_wf_plus (:,:, prep , np ))) prep_E_Kin ( prep , np , 2 ) = volume_integrate ( f = prep_wf_minus (:,:, prep , np )& * ( - 1 d0 * HBAR2_over_2m * prep_lap_wf_minus (:,:, prep , np ))) prep_E_B ( prep , np , 1 ) = volume_integrate ( f = prep_wf_plus (:,:, prep , np ) * prep_Bpsi_plus (:,:, prep , np )) prep_E_B ( prep , np , 2 ) = volume_integrate ( f = prep_wf_minus (:,:, prep , np ) * prep_Bpsi_minus (:,:, prep , np )) prep_E_W ( prep , np , 1 ) = volume_integrate ( f = prep_wf_plus (:,:, prep , np ) * prep_Wpsi_plus (:,:, prep , np )) prep_E_W ( prep , np , 2 ) = volume_integrate ( f = prep_wf_minus (:,:, prep , np ) * prep_Wpsi_minus (:,:, prep , np )) !prep_E(prep,np) = prep_E_U(prep,np,1) + prep_E_U(prep,np,2) + prep_E_Kin(prep,np,1) + prep_E_Kin(prep,np,2) & !                 -prep_E_B(prep,np,1) - prep_E_B(prep,np,2) + prep_E_W(prep,np,1) + prep_E_W(prep,np,2) prep_E ( prep , np ) = volume_integrate ( f = prep_wf_plus (:,:, prep , np ) * prep_Hpsi_plus (:,:, prep , np )) & + volume_integrate ( f = prep_wf_minus (:,:, prep , np ) * prep_Hpsi_minus (:,:, prep , np )) end do end do do np = 1 , 2 do prep = 1 , prep_number prep_one_particle_E2 ( prep , np ) = volume_integrate ( f = prep_Hpsi_plus (:,:, prep , np ) ** 2 ) & + volume_integrate ( f = prep_Hpsi_minus (:,:, prep , np ) ** 2 ) end do end do end subroutine calc_one_particle_energy subroutine calc_Hpsi use , intrinsic :: iso_fortran_env , only : int32 use constants_and_parameters , only : HBAR2_over_2m , is_use_B , is_use_W , lam => lagrange_multiplier use global_variables , only : prep_Hpsi_plus , prep_Hpsi_minus , prep_lap_wf_plus , prep_lap_wf_minus & , prep_Upsi_plus , prep_Upsi_minus , prep_Bpsi_plus , prep_Bpsi_minus , prep_Wpsi_plus , prep_Wpsi_minus & , Nr , Nz , z_vec , dz , prep_wf_plus , prep_wf_minus implicit none integer ( int32 ) :: j call calc_Upsi call calc_Bpsi call calc_Wpsi prep_Hpsi_plus (:,:,:,:) = prep_Upsi_plus (:,:,:,:) - HBAR2_over_2m * prep_lap_wf_plus (:,:,:,:) prep_Hpsi_minus (:,:,:,:) = prep_Upsi_minus (:,:,:,:) - HBAR2_over_2m * prep_lap_wf_minus (:,:,:,:) ! Bpsiには，密度依存部分のみを含めている． if ( is_use_B ) then prep_Hpsi_plus (:,:,:,:) = prep_Hpsi_plus (:,:,:,:) - prep_Bpsi_plus (:,:,:,:) prep_Hpsi_minus (:,:,:,:) = prep_Hpsi_minus (:,:,:,:) - prep_Bpsi_minus (:,:,:,:) end if ! BHpsiはマイナスでたさないといけない if ( is_use_W ) then prep_Hpsi_plus (:,:,:,:) = prep_Hpsi_plus (:,:,:,:) + prep_Wpsi_plus (:,:,:,:) prep_Hpsi_minus (:,:,:,:) = prep_Hpsi_minus (:,:,:,:) + prep_Wpsi_minus (:,:,:,:) end if ! 未定定数を引く !do j=1,Nz !    prep_Hpsi_plus(:,j,:,:) = prep_Hpsi_plus(:,j,:,:) & !                            - lam*(z_vec(j)**2*prep_wf_plus(:,j,:,:) & !                            - 2d0*z_vec(j)*(Nz/2d0*dz)*prep_wf_plus(:,j,:,:) & !                            + (Nz/2d0*dz)**2*prep_wf_plus(:,j,:,:)) !    prep_Hpsi_minus(:,j,:,:) = prep_Hpsi_minus(:,j,:,:) & !                            - lam*(z_vec(j)**2*prep_wf_minus(:,j,:,:) & !                            - 2d0*z_vec(j)*(Nz/2d0*dz)*prep_wf_minus(:,j,:,:) & !                            + (Nz/2d0*dz)**2*prep_wf_minus(:,j,:,:)) !end do end subroutine calc_Hpsi subroutine calc_IMAG_Evolution ( np_int ) use constants_and_parameters , cdt => imaginary_time_step use global_variables , only : prep_wf_plus , prep_wf_minus , prep_Hpsi_plus , prep_Hpsi_minus , prep_Hpsi2_plus , prep_Hpsi2_minus implicit none integer ( int32 ), intent ( in ) :: np_int prep_wf_plus (:,:,:, np_int ) = prep_wf_plus (:,:,:, np_int ) - cdt / HBARC * prep_Hpsi_plus (:,:,:, np_int ) prep_wf_minus (:,:,:, np_int ) = prep_wf_minus (:,:,:, np_int ) - cdt / HBARC * prep_Hpsi_minus (:,:,:, np_int ) if ( is_use_second_imag ) then prep_wf_plus (:,:,:, np_int ) = prep_wf_plus (:,:,:, np_int ) + cdt ** 2 / HBARC ** 2 / 2 d0 * prep_Hpsi2_plus (:,:,:, np_int ) prep_wf_minus (:,:,:, np_int ) = prep_wf_minus (:,:,:, np_int ) + cdt ** 2 / HBARC ** 2 / 2 d0 * prep_Hpsi2_minus (:,:,:, np_int ) end if end subroutine calc_IMAG_Evolution subroutine Schmidt_orthogonalization ( np_int ) ! 陽子と中性子別々で正規直交化 use constants_and_parameters use global_variables , only : prep_wf_plus , prep_wf_minus , idx => prep_idx_array implicit none integer ( int32 ), intent ( in ) :: np_int integer ( int32 ) :: k , prep integer ( int32 ) :: tar , sub ! 直交化の対象と引き算をするインデックス real ( real64 ) :: ovlp , norm real ( real64 ) :: coef do prep = 1 , prep_number tar = idx ( prep , np_int ) ! 直交化の対象インデックス. idxはエネルギーの昇順にソート済み ! 直交化パート do k = 1 , prep - 1 sub = idx ( k , np_int ) ! 引き算をするインデックス ovlp = prep_wf_overlap ( tar , sub , np_int ) norm = prep_wf_overlap ( sub , sub , np_int ) coef = ovlp / norm prep_wf_plus (:,:, tar , np_int ) = prep_wf_plus (:,:, tar , np_int ) - coef * prep_wf_plus (:,:, sub , np_int ) prep_wf_minus (:,:, tar , np_int ) = prep_wf_minus (:,:, tar , np_int ) - coef * prep_wf_minus (:,:, sub , np_int ) end do ! 規格化パート norm = prep_wf_overlap ( tar , tar , np_int ) prep_wf_plus (:,:, tar , np_int ) = prep_wf_plus (:,:, tar , np_int ) / sqrt ( norm ) prep_wf_minus (:,:, tar , np_int ) = prep_wf_minus (:,:, tar , np_int ) / sqrt ( norm ) end do end subroutine Schmidt_orthogonalization function prep_wf_overlap ( idx_1 , idx_2 , np_int ) result ( ovlp ) use , intrinsic :: iso_fortran_env , only : int32 , real64 use math_integrate , only : volume_integrate use global_variables , only : prep_wf_plus , prep_wf_minus implicit none integer ( int32 ), intent ( in ) :: idx_1 integer ( int32 ), intent ( in ) :: idx_2 integer ( int32 ), intent ( in ) :: np_int real ( real64 ) :: ovlp real ( real64 ) :: term_plus , term_minus term_plus = volume_integrate ( f = prep_wf_plus (:,:, idx_1 , np_int ) * prep_wf_plus (:,:, idx_2 , np_int )) term_minus = volume_integrate ( f = prep_wf_minus (:,:, idx_1 , np_int ) * prep_wf_minus (:,:, idx_2 , np_int )) ovlp = term_plus + term_minus end function prep_wf_overlap subroutine calc_Upsi use , intrinsic :: iso_fortran_env , only : int32 use constants_and_parameters , only : prep_number use global_variables , only : prep_wf_plus , prep_wf_minus , U_n , U_p , prep_Upsi_plus , prep_Upsi_minus implicit none integer ( int32 ) :: prep do prep = 1 , prep_number prep_Upsi_plus (:,:, prep , 1 ) = U_n (:,:) * prep_wf_plus (:,:, prep , 1 ) prep_Upsi_minus (:,:, prep , 1 ) = U_n (:,:) * prep_wf_minus (:,:, prep , 1 ) prep_Upsi_plus (:,:, prep , 2 ) = U_p (:,:) * prep_wf_plus (:,:, prep , 2 ) prep_Upsi_minus (:,:, prep , 2 ) = U_p (:,:) * prep_wf_minus (:,:, prep , 2 ) !print*, maxval(U_n(:,:)) !stop end do end subroutine calc_Upsi subroutine calc_Wpsi use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : zI => imaginary_unit , prep_number use global_variables , only : W_n , W_p & , prep_dz_wf_minus , prep_dz_wf_plus , prep_dr_wf_minus , prep_dr_wf_plus & , prep_SDNWP , prep_SDNWM , prep_Wpsi_plus , prep_Wpsi_minus implicit none integer ( int32 ) :: prep do prep = 1 , prep_number prep_Wpsi_plus (:,:, prep , 1 ) = W_n (:,:, 3 ) * ( prep_SDNWP (:,:, prep , 1 ) - prep_dz_wf_plus (:,:, prep , 1 )) & + W_n (:,:, 1 ) * ( prep_SDNWM (:,:, prep , 1 ) - prep_dr_wf_plus (:,:, prep , 1 )) prep_Wpsi_minus (:,:, prep , 1 ) = W_n (:,:, 1 ) * ( prep_SDNWP (:,:, prep , 1 ) - prep_dr_wf_minus (:,:, prep , 1 )) & - W_n (:,:, 3 ) * ( prep_SDNWM (:,:, prep , 1 ) + prep_dz_wf_minus (:,:, prep , 1 )) prep_Wpsi_plus (:,:, prep , 2 ) = W_p (:,:, 3 ) * ( prep_SDNWP (:,:, prep , 2 ) - prep_dz_wf_plus (:,:, prep , 2 )) & + W_p (:,:, 1 ) * ( prep_SDNWM (:,:, prep , 2 ) - prep_dr_wf_plus (:,:, prep , 2 )) prep_Wpsi_minus (:,:, prep , 2 ) = W_p (:,:, 1 ) * ( prep_SDNWP (:,:, prep , 2 ) - prep_dr_wf_minus (:,:, prep , 2 )) & - W_p (:,:, 3 ) * ( prep_SDNWM (:,:, prep , 2 ) + prep_dz_wf_minus (:,:, prep , 2 )) end do end subroutine calc_Wpsi subroutine calc_Bpsi use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : Nr , Nz , prep_number use math_derivation , only : math_diff_r_9point , math_diff_z_9point use global_variables , only : B_n , B_p & , prep_dr_wf_plus , prep_dr_wf_minus , prep_dz_wf_plus , prep_dz_wf_minus & , prep_lap_wf_plus , prep_lap_wf_minus , prep_Bpsi_plus , prep_Bpsi_minus implicit none real ( real64 ), allocatable :: dr_B (:,:), dz_B (:,:) integer ( int32 ) :: prep , np_int allocate ( dr_B ( Nr , Nz )) allocate ( dz_B ( Nr , Nz )) dr_B (:,:) = math_diff_r_9point ( B_n (:,:)) dz_B (:,:) = math_diff_z_9point ( B_n (:,:)) do prep = 1 , prep_number prep_Bpsi_plus (:,:, prep , 1 ) = B_n (:,:) * prep_lap_wf_plus (:,:, prep , 1 ) & + dr_B (:,:) * prep_dr_wf_plus (:,:, prep , 1 ) & + dz_B (:,:) * prep_dz_wf_plus (:,:, prep , 1 ) prep_Bpsi_minus (:,:, prep , 1 ) = B_n (:,:) * prep_lap_wf_minus (:,:, prep , 1 ) & + dr_B (:,:) * prep_dr_wf_minus (:,:, prep , 1 ) & + dz_B (:,:) * prep_dz_wf_minus (:,:, prep , 1 ) end do dr_B (:,:) = math_diff_r_9point ( B_p (:,:)) dz_B (:,:) = math_diff_z_9point ( B_p (:,:)) do prep = 1 , prep_number prep_Bpsi_plus (:,:, prep , 2 ) = B_p (:,:) * prep_lap_wf_plus (:,:, prep , 2 ) & + dr_B (:,:) * prep_dr_wf_plus (:,:, prep , 2 ) & + dz_B (:,:) * prep_dz_wf_plus (:,:, prep , 2 ) prep_Bpsi_minus (:,:, prep , 2 ) = B_p (:,:) * prep_lap_wf_minus (:,:, prep , 2 ) & + dr_B (:,:) * prep_dr_wf_minus (:,:, prep , 2 ) & + dz_B (:,:) * prep_dz_wf_minus (:,:, prep , 2 ) end do end subroutine calc_Bpsi subroutine calc_density_and_lap use , intrinsic :: ieee_arithmetic use , intrinsic :: iso_fortran_env , only : int32 , real64 use constants_and_parameters , only : Nr , Nz , num_n , num_p , is_use_dd , z_center , str_z use global_variables , only : rho_n , rho_p , wf_plus , wf_minus , lap_rho_n , lap_rho_p , r_vec & , dr_rho_n , dr_rho_p , dz_rho_n , dz_rho_p , ddr_rho_n , ddr_rho_p , ddz_rho_n , ddz_rho_p , z_vec use math_integrate , only : volume_integrate use math_derivation , only : math_diff_r_9point , math_diff_z_9point , math_diff_2r_9point , math_diff_2z_9point implicit none integer ( int32 ) :: k , i , j real ( real64 ), allocatable :: tmp (:,:) allocate ( tmp ( Nr , Nz )) rho_n (:,:) = 0.0d0 rho_p (:,:) = 0.0d0 do k = 1 , num_n rho_n (:,:) = rho_n (:,:) + abs ( wf_plus (:,:, k )) ** 2 + abs ( wf_minus (:,:, k )) ** 2 end do do k = 1 , num_p rho_p (:,:) = rho_p (:,:) + abs ( wf_plus (:,:, num_n + k )) ** 2 + abs ( wf_minus (:,:, num_n + k )) ** 2 end do ! Correction center of the nucleus do j = 1 , Nz do i = 1 , Nr tmp ( i , j ) = ( rho_n ( i , j ) + rho_p ( i , j )) * z_vec ( j ) end do end do z_center = volume_integrate ( f = tmp (:,:)) / volume_integrate ( f = rho_n (:,:) + rho_p (:,:)) !print*, 'z_center = ', z_center write ( str_z , '(f0.2)' ) z_center dr_rho_n (:,:) = math_diff_r_9point ( f = rho_n (:,:)) dr_rho_p (:,:) = math_diff_r_9point ( f = rho_p (:,:)) dz_rho_n (:,:) = math_diff_z_9point ( f = rho_n (:,:)) dz_rho_p (:,:) = math_diff_z_9point ( f = rho_p (:,:)) if ( is_use_dd ) then ddr_rho_n (:,:) = math_diff_2r_9point ( f = rho_n (:,:)) ddr_rho_p (:,:) = math_diff_2r_9point ( f = rho_p (:,:)) ddz_rho_n (:,:) = math_diff_2z_9point ( f = rho_n (:,:)) ddz_rho_p (:,:) = math_diff_2z_9point ( f = rho_p (:,:)) else ddr_rho_n (:,:) = math_diff_r_9point ( f = dr_rho_n (:,:)) ddr_rho_p (:,:) = math_diff_r_9point ( f = dr_rho_p (:,:)) ddz_rho_n (:,:) = math_diff_z_9point ( f = dz_rho_n (:,:)) ddz_rho_p (:,:) = math_diff_z_9point ( f = dz_rho_p (:,:)) end if do j = 1 , Nz do i = 1 , Nr lap_rho_n ( i , j ) = ddr_rho_n ( i , j ) + dr_rho_n ( i , j ) / r_vec ( i ) + ddz_rho_n ( i , j ) lap_rho_p ( i , j ) = ddr_rho_p ( i , j ) + dr_rho_p ( i , j ) / r_vec ( i ) + ddz_rho_p ( i , j ) end do end do deallocate ( tmp ) end subroutine calc_density_and_lap subroutine calc_spin_orbit_density_and_div ! J13=J31=0 use , intrinsic :: iso_fortran_env , only : int32 , real64 use , intrinsic :: ieee_arithmetic use constants_and_parameters use math_derivation , only : math_diff_r_9point , math_diff_z_9point use global_variables , only : j_n => spin_orbit_dens_n , j_p => spin_orbit_dens_p , & div_j_n => div_spin_orbit_dens_n , div_j_p => div_spin_orbit_dens_p , & wf_plus , wf_minus , m => magnetic_q_num , dz_wf_plus , dz_wf_minus , dr_wf_plus , dr_wf_minus , & r_vec , tau_n => kinetic_dens_n , tau_p => kinetic_dens_p & , SDNWP , SDNWM , r_vec implicit none integer ( int32 ) :: i , j , k , kp real ( real64 ), allocatable :: J12 (:,:), J21 (:,:), J23 (:,:), J32 (:,:) real ( real64 ), allocatable :: dr_j (:,:), dz_j (:,:) allocate ( J12 ( Nr , Nz )) allocate ( J21 ( Nr , Nz )) allocate ( J23 ( Nr , Nz )) allocate ( J32 ( Nr , Nz )) allocate ( dr_j ( Nr , Nz )) allocate ( dz_j ( Nr , Nz )) J12 = 0 d0 ; J21 = 0 d0 ; J23 = 0 d0 ; J32 = 0 d0 do k = 1 , num_n do j = 1 , Nz do i = 1 , Nr J12 ( i , j ) = J12 ( i , j ) + wf_minus ( i , j , k ) * dr_wf_plus ( i , j , k ) - wf_plus ( i , j , k ) * dr_wf_minus ( i , j , k ) J21 ( i , j ) = J21 ( i , j ) + dble ( 2 * m ( k ) + 1 ) / r_vec ( i ) * wf_plus ( i , j , k ) * wf_minus ( i , j , k ) J23 ( i , j ) = J23 ( i , j ) + ( dble ( m ( k )) * wf_plus ( i , j , k ) ** 2 + dble ( m ( k ) + 1 ) * wf_minus ( i , j , k ) ** 2 ) / r_vec ( i ) J32 ( i , j ) = J32 ( i , j ) + wf_minus ( i , j , k ) * dz_wf_plus ( i , j , k ) - wf_plus ( i , j , k ) * dz_wf_minus ( i , j , k ) end do end do end do j_n (:,:, 1 ) = J23 (:,:) - J32 (:,:) j_n (:,:, 2 ) = 0 d0 j_n (:,:, 3 ) = J12 (:,:) - J21 (:,:) if ( not_divJ ) then div_j_n (:,:) = 0 d0 else !do k=1,num_n !    div_j_n(:,:) = div_j_n(:,:) + SDNWP(:,:,k)**2 + SDNWM(:,:,k)**2 !end do !div_j_n(:,:) = div_j_n(:,:) - tau_n(:,:) dr_j (:,:) = math_diff_r_9point ( f = j_n (:,:, 1 )) dz_j (:,:) = math_diff_z_9point ( f = j_n (:,:, 3 )) do j = 1 , Nz do i = 1 , Nr div_j_n ( i , j ) = j_n ( i , j , 1 ) / r_vec ( i ) + dr_j ( i , j ) + dz_j ( i , j ) end do end do end if J12 = 0 d0 ; J21 = 0 d0 ; J23 = 0 d0 ; J32 = 0 d0 do k = 1 , num_p kp = num_n + k do j = 1 , Nz do i = 1 , Nr J12 ( i , j ) = J12 ( i , j ) + wf_minus ( i , j , kp ) * dr_wf_plus ( i , j , kp ) - wf_plus ( i , j , kp ) * dr_wf_minus ( i , j , kp ) J21 ( i , j ) = J21 ( i , j ) + dble ( 2 * m ( kp ) + 1 ) / r_vec ( i ) * wf_plus ( i , j , kp ) * wf_minus ( i , j , kp ) J23 ( i , j ) = J23 ( i , j ) + ( dble ( m ( kp )) * wf_plus ( i , j , kp ) ** 2 + dble ( m ( kp ) + 1 ) * wf_minus ( i , j , kp ) ** 2 ) / r_vec ( i ) J32 ( i , j ) = J32 ( i , j ) + wf_minus ( i , j , kp ) * dz_wf_plus ( i , j , kp ) - wf_plus ( i , j , kp ) * dz_wf_minus ( i , j , kp ) end do end do end do j_p (:,:, 1 ) = J23 (:,:) - J32 (:,:) j_p (:,:, 2 ) = 0 d0 j_p (:,:, 3 ) = J12 (:,:) - J21 (:,:) if ( not_divJ ) then div_j_p (:,:) = 0 d0 else !do k=1,num_p !    kp = num_n + k !    div_j_p(:,:) = div_j_p(:,:) + SDNWP(:,:,kp)**2 + SDNWM(:,:,kp)**2 !end do !div_j_p(:,:) = div_j_p(:,:) - tau_p(:,:) dr_j (:,:) = math_diff_r_9point ( f = j_p (:,:, 1 )) dz_j (:,:) = math_diff_z_9point ( f = j_p (:,:, 3 )) do j = 1 , Nz do i = 1 , Nr div_j_p ( i , j ) = j_p ( i , j , 1 ) / r_vec ( i ) + dr_j ( i , j ) + dz_j ( i , j ) end do end do end if deallocate ( J12 ) deallocate ( J21 ) deallocate ( J23 ) deallocate ( J32 ) end subroutine calc_spin_orbit_density_and_div subroutine calc_kinetic_density use , intrinsic :: iso_fortran_env , only : int32 , real64 use global_variables , only : tau_n => kinetic_dens_n , tau_p => kinetic_dens_p , m => magnetic_q_num & , rho_n , rho_p , dr_wf_plus , dr_wf_minus , dz_wf_plus , dz_wf_minus , wf_plus , wf_minus , r_vec & , thomas_fermi_n , thomas_fermi_p use constants_and_parameters , only : Nr , Nz , num_n , num_p , pi implicit none integer ( int32 ) :: i , j , k real ( real64 ), allocatable :: tau_per_nuc (:,:) ! [fm&#94;-3] (r,z) allocate ( tau_per_nuc ( Nr , Nz )) tau_n (:,:) = 0.0d0 tau_p (:,:) = 0.0d0 do k = 1 , num_n ! 32b式を参照して、各核子のtauを計算している。各項が正しいか検算 do j = 1 , Nz do i = 1 , Nr tau_per_nuc ( i , j ) = abs ( dr_wf_plus ( i , j , k )) ** 2 + abs ( dz_wf_plus ( i , j , k )) ** 2 & + abs ( dr_wf_minus ( i , j , k )) ** 2 + abs ( dz_wf_minus ( i , j , k )) ** 2 & + ( dble ( m ( k )) / r_vec ( i )) ** 2 * abs ( wf_plus ( i , j , k )) ** 2 & + ( dble ( m ( k ) + 1 ) / r_vec ( i )) ** 2 * abs ( wf_minus ( i , j , k )) ** 2 end do end do tau_n (:,:) = tau_n (:,:) + tau_per_nuc (:,:) ! 1つの核子のtauを足し合わせている。 end do do k = 1 , num_p do j = 1 , Nz do i = 1 , Nr tau_per_nuc ( i , j ) = abs ( dr_wf_plus ( i , j , num_n + k )) ** 2 + abs ( dz_wf_plus ( i , j , num_n + k )) ** 2 & + abs ( dr_wf_minus ( i , j , num_n + k )) ** 2 + abs ( dz_wf_minus ( i , j , num_n + k )) ** 2 & + ( dble ( m ( num_n + k )) / r_vec ( i )) ** 2 * abs ( wf_plus ( i , j , num_n + k )) ** 2 & + ( dble ( m ( num_n + k ) + 1 ) / r_vec ( i )) ** 2 * abs ( wf_minus ( i , j , num_n + k )) ** 2 end do end do tau_p (:,:) = tau_p (:,:) + tau_per_nuc (:,:) end do thomas_fermi_n (:,:) = 3 d0 / 5 d0 * ( 3 d0 * pi ** 2 ) ** ( 2 d0 / 3 d0 ) * rho_n (:,:) ** ( 5 d0 / 3 d0 ) ! ちゃんとした密度だったら計算しているのと同じような形になるはず thomas_fermi_p (:,:) = 3 d0 / 5 d0 * ( 3 d0 * pi ** 2 ) ** ( 2 d0 / 3 d0 ) * rho_p (:,:) ** ( 5 d0 / 3 d0 ) end subroutine calc_kinetic_density subroutine alloc_fields use , intrinsic :: iso_fortran_env use :: global_variables use :: constants_and_parameters implicit none integer ( int32 ) :: nuc integer ( int32 ) :: prep nuc = num_n + num_p prep = prep_number !-- Density and potential (caluculated by Occupied Orbitals) -- allocate ( rho_n ( Nr , Nz ) ) ! [fm&#94;-3]  (r,z) allocate ( rho_p ( Nr , Nz ) ) ! [fm&#94;-3]  (r,z) allocate ( dr_rho_n ( Nr , Nz ) ) ! [fm&#94;-4]  (r,z) allocate ( dr_rho_p ( Nr , Nz ) ) ! [fm&#94;-4]  (r,z) allocate ( dz_rho_n ( Nr , Nz ) ) ! [fm&#94;-4]  (r,z) allocate ( dz_rho_p ( Nr , Nz ) ) ! [fm&#94;-4]  (r,z) allocate ( ddr_rho_n ( Nr , Nz ) ) ! [fm&#94;-5]  (r,z) allocate ( ddr_rho_p ( Nr , Nz ) ) ! [fm&#94;-5]  (r,z) allocate ( ddz_rho_n ( Nr , Nz ) ) ! [fm&#94;-5]  (r,z) allocate ( ddz_rho_p ( Nr , Nz ) ) ! [fm&#94;-5]  (r,z) allocate ( lap_rho_n ( Nr , Nz ) ) ! [fm&#94;-5]  (r,z) allocate ( lap_rho_p ( Nr , Nz ) ) ! [fm&#94;-5]  (r,z) allocate ( kinetic_dens_n ( Nr , Nz ) ) ! [fm&#94;-3]  (r,z) allocate ( kinetic_dens_p ( Nr , Nz ) ) ! [fm&#94;-3]  (r,z) allocate ( thomas_fermi_n ( Nr , Nz ) ) ! [fm&#94;-3]  (r,z) allocate ( thomas_fermi_p ( Nr , Nz ) ) ! [fm&#94;-3]  (r,z) allocate ( spin_orbit_dens_n ( Nr , Nz , 3 ) ) ! [fm&#94;-3]  (r,z,vec component) allocate ( spin_orbit_dens_p ( Nr , Nz , 3 ) ) ! [fm&#94;-3]  (r,z,vec component) allocate ( div_spin_orbit_dens_n ( Nr , Nz ) ) ! [fm&#94;-4]  (r,z) allocate ( div_spin_orbit_dens_p ( Nr , Nz ) ) ! [fm&#94;-4]  (r,z) allocate ( U_n ( Nr , Nz ) ) ! [MeV] (r,z) allocate ( U_p ( Nr , Nz ) ) ! [MeV] (r,z) allocate ( B_n ( Nr , Nz ) ) ! [MeV] (r,z) allocate ( B_p ( Nr , Nz ) ) ! [MeV] (r,z) allocate ( W_n ( Nr , Nz , 3 ) ) ! [MeV] (r,z,component) allocate ( W_p ( Nr , Nz , 3 ) ) ! [MeV] (r,z,component) allocate ( direct_Coulomb_pot ( Nr , Nz ), source = 0 d0 ) ! [MeV] (r,z) allocate ( exchange_Coulomb_pot ( Nr , Nz ), source = 0 d0 ) ! [MeV] (r,z ! -- All Orbitals(Occupied state / All state : prefix = prep) -- allocate ( prep_idx_array ( prep , 2 ) ) ! index of nucleon allocate ( magnetic_q_num ( nuc ) ) ! magnetic quantum number allocate ( prep_magnetic_q_num ( prep , 2 ) ) ! magnetic quantum number (prepared) allocate ( init_rzm_to_write ( prep ) ) ! (idx,nlm,p/n) (prepared) allocate ( prep_one_particle_E ( prep , 2 ) ) ! [MeV] 1粒子エネルギー (prepared) allocate ( prep_one_particle_E2 ( prep , 2 )) allocate ( prep_one_E_Kin ( prep , 2 , 2 )) allocate ( prep_one_E_U ( prep , 2 , 2 )) allocate ( prep_one_E_B ( prep , 2 , 2 )) allocate ( prep_one_E_W ( prep , 2 , 2 )) allocate ( wf_plus ( Nr , Nz , nuc ) ) ! [fm&#94;-3/2]  (r,z,nucleon) allocate ( wf_minus ( Nr , Nz , nuc ) ) ! [fm&#94;-3/2]  (r,z,nucleon) allocate ( prep_wf_plus ( Nr , Nz , prep , 2 ) ) ! [fm&#94;-3/2]  (r,z,prepsize) allocate ( prep_wf_minus ( Nr , Nz , prep , 2 ) ) ! [fm&#94;-3/2]  (r,z,prepsize) !----- derivative of wave function ----- allocate ( dr_wf_plus ( Nr , Nz , nuc ) ) allocate ( dz_wf_plus ( Nr , Nz , nuc ) ) allocate ( ddr_wf_plus ( Nr , Nz , nuc ) ) allocate ( ddz_wf_plus ( Nr , Nz , nuc ) ) allocate ( lap_wf_plus ( Nr , Nz , nuc ) ) allocate ( prep_dr_wf_plus ( Nr , Nz , prep , 2 ) ) allocate ( prep_dz_wf_plus ( Nr , Nz , prep , 2 ) ) allocate ( prep_ddr_wf_plus ( Nr , Nz , prep , 2 ) ) allocate ( prep_ddz_wf_plus ( Nr , Nz , prep , 2 ) ) allocate ( prep_lap_wf_plus ( Nr , Nz , prep , 2 ) ) allocate ( dr_wf_minus ( Nr , Nz , nuc ) ) allocate ( dz_wf_minus ( Nr , Nz , nuc ) ) allocate ( ddr_wf_minus ( Nr , Nz , nuc ) ) allocate ( ddz_wf_minus ( Nr , Nz , nuc ) ) allocate ( lap_wf_minus ( Nr , Nz , nuc ) ) allocate ( prep_dr_wf_minus ( Nr , Nz , prep , 2 ) ) allocate ( prep_dz_wf_minus ( Nr , Nz , prep , 2 ) ) allocate ( prep_ddr_wf_minus ( Nr , Nz , prep , 2 )) allocate ( prep_ddz_wf_minus ( Nr , Nz , prep , 2 )) allocate ( prep_lap_wf_minus ( Nr , Nz , prep , 2 )) allocate ( prep_Upsi_plus ( Nr , Nz , prep , 2 ) ) allocate ( prep_Upsi_minus ( Nr , Nz , prep , 2 ) ) allocate ( prep_Wpsi_plus ( Nr , Nz , prep , 2 ) ) allocate ( prep_Wpsi_minus ( Nr , Nz , prep , 2 ) ) allocate ( prep_Bpsi_plus ( Nr , Nz , prep , 2 ) ) allocate ( prep_Bpsi_minus ( Nr , Nz , prep , 2 ) ) !----- use for calculation ----- ! SDNWP/M = sigma dot nabla plus/minus allocate ( SDNWP ( Nr , Nz , nuc ) ) ! [fm&#94;-3/2]  (r,z,nucleon) allocate ( SDNWM ( Nr , Nz , nuc ) ) ! [fm&#94;-3/2]  (r,z,nucleon) allocate ( prep_SDNWP ( Nr , Nz , prep , 2 ) ) ! [fm&#94;-3/2]  (r,z,nucleon) allocate ( prep_SDNWM ( Nr , Nz , prep , 2 ) ) ! [fm&#94;-3/2]  (r,z,nucleon) ! Hpsi allocate ( prep_Hpsi2_plus ( Nr , Nz , prep , 2 ) ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) allocate ( prep_Hpsi2_minus ( Nr , Nz , prep , 2 ) ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) allocate ( prep_Hpsi_plus ( Nr , Nz , prep , 2 ) ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) allocate ( prep_Hpsi_minus ( Nr , Nz , prep , 2 ) ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) !-- Grid variables -- allocate ( r_vec ( Nr ) ) ! [fm] r position allocate ( z_vec ( Nz ) ) ! [fm] z position end subroutine alloc_fields subroutine dealloc_fields use :: global_variables implicit none !-- Density and potential (caluculated by Occupied Orbitals) -- deallocate ( rho_n ) ! [fm&#94;-3]  (r,z) deallocate ( rho_p ) ! [fm&#94;-3]  (r,z) deallocate ( dr_rho_n ) ! [fm&#94;-4]  (r,z) deallocate ( dr_rho_p ) ! [fm&#94;-4]  (r,z) deallocate ( dz_rho_n ) ! [fm&#94;-4]  (r,z) deallocate ( dz_rho_p ) ! [fm&#94;-4]  (r,z) deallocate ( ddr_rho_n ) ! [fm&#94;-5]  (r,z) deallocate ( ddr_rho_p ) ! [fm&#94;-5]  (r,z) deallocate ( ddz_rho_n ) ! [fm&#94;-5]  (r,z) deallocate ( ddz_rho_p ) ! [fm&#94;-5]  (r,z) deallocate ( lap_rho_n ) ! [fm&#94;-5]  (r,z) deallocate ( lap_rho_p ) ! [fm&#94;-5]  (r,z) deallocate ( kinetic_dens_n ) ! [fm&#94;-3]  (r,z) deallocate ( kinetic_dens_p ) ! [fm&#94;-3]  (r,z) deallocate ( thomas_fermi_n ) deallocate ( thomas_fermi_p ) deallocate ( spin_orbit_dens_n ) ! [fm&#94;-3]  (r,z,vec component) deallocate ( spin_orbit_dens_p ) ! [fm&#94;-3]  (r,z,vec component) deallocate ( div_spin_orbit_dens_n ) ! [fm&#94;-4]  (r,z) deallocate ( div_spin_orbit_dens_p ) ! [fm&#94;-4]  (r,z) deallocate ( U_n ) ! [MeV] (r,z) deallocate ( U_p ) ! [MeV] (r,z) deallocate ( B_n ) ! [MeV] (r,z) deallocate ( B_p ) ! [MeV] (r,z) deallocate ( W_n ) ! [MeV] (r,z,component) deallocate ( W_p ) ! [MeV] (r,z,component) deallocate ( direct_Coulomb_pot ) ! [MeV] (r,z) deallocate ( exchange_Coulomb_pot ) ! [MeV] (r,z) ! -- All Orbitals(Occupied state / All state : prefix = prep) -- deallocate ( prep_idx_array ) ! index of nucleon deallocate ( magnetic_q_num ) ! magnetic quantum number deallocate ( prep_magnetic_q_num ) ! magnetic quantum number (prepared) deallocate ( init_rzm_to_write ) ! (idx,nlm,p/n) (prepared) deallocate ( prep_one_particle_E ) ! [MeV] 1粒子エネルギー (prepared) deallocate ( prep_one_particle_E2 ) deallocate ( prep_one_E_Kin ) deallocate ( prep_one_E_U ) deallocate ( prep_one_E_B ) deallocate ( prep_one_E_W ) deallocate ( wf_plus ) ! [fm&#94;-3/2]  (r,z,nucleon) deallocate ( wf_minus ) ! [f&#94;-3/2]  (r,z,nucleon) deallocate ( prep_wf_plus ) ! [fm&#94;-3/2]  (r,z,prepsize) deallocate ( prep_wf_minus ) ! [fm&#94;-3/2]  (r,z,prepsize) !----- derivative of wave function ----- deallocate ( dr_wf_plus ) deallocate ( dz_wf_plus ) deallocate ( ddr_wf_plus ) deallocate ( ddz_wf_plus ) deallocate ( lap_wf_plus ) deallocate ( prep_dr_wf_plus ) deallocate ( prep_dz_wf_plus ) deallocate ( prep_ddr_wf_plus ) deallocate ( prep_ddz_wf_plus ) deallocate ( prep_lap_wf_plus ) deallocate ( dr_wf_minus ) deallocate ( dz_wf_minus ) deallocate ( ddr_wf_minus ) deallocate ( ddz_wf_minus ) deallocate ( lap_wf_minus ) deallocate ( prep_dr_wf_minus ) deallocate ( prep_dz_wf_minus ) deallocate ( prep_ddr_wf_minus ) deallocate ( prep_ddz_wf_minus ) deallocate ( prep_lap_wf_minus ) deallocate ( prep_Upsi_plus ) deallocate ( prep_Wpsi_plus ) deallocate ( prep_Bpsi_plus ) deallocate ( prep_Upsi_minus ) deallocate ( prep_Wpsi_minus ) deallocate ( prep_Bpsi_minus ) !----- use for calculation ----- ! SDNWP/M = sigma dot nabla plus/minus deallocate ( SDNWP ) ! [fm&#94;-3/2]  (r,z,nucleon) deallocate ( SDNWM ) ! [fm&#94;-3/2]  (r,z,nucleon) deallocate ( prep_SDNWP ) ! [fm&#94;-3/2]  (r,z,nucleon) deallocate ( prep_SDNWM ) ! [fm&#94;-3/2]  (r,z,nucleon) ! Hpsi deallocate ( prep_Hpsi2_plus ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) deallocate ( prep_Hpsi2_minus ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) deallocate ( prep_Hpsi_plus ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) deallocate ( prep_Hpsi_minus ) ! [MeV fm&#94;-3/2]  (r,z,nucleon) !-- Grid variables -- deallocate ( r_vec ) ! [fm] r position deallocate ( z_vec ) ! [fm] z position end subroutine dealloc_fields end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"harmonic_occ.f90 – Axial Skyrme Hartree-Fock (SHF) Code using Fortran Free-Form.","text":"This file depends on sourcefile~~harmonic_occ.f90~~EfferentGraph sourcefile~harmonic_occ.f90 harmonic_occ.f90 sourcefile~constants_and_parameters.f90 constants_and_parameters.f90 sourcefile~harmonic_occ.f90->sourcefile~constants_and_parameters.f90 sourcefile~global_variables.f90 global_variables.f90 sourcefile~harmonic_occ.f90->sourcefile~global_variables.f90 sourcefile~spacial_function.f90 spacial_function.f90 sourcefile~harmonic_occ.f90->sourcefile~spacial_function.f90 sourcefile~global_variables.f90->sourcefile~constants_and_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~harmonic_occ.f90~~AfferentGraph sourcefile~harmonic_occ.f90 harmonic_occ.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~harmonic_occ.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules harmonic_occ_wf Source Code harmonic_occ.f90 Source Code module harmonic_occ_wf use , intrinsic :: iso_fortran_env use :: constants_and_parameters implicit none real ( real64 ) :: hboma real ( real64 ) :: xpi = sqrt ( 4.0d0 / ( 5.0d0 * pi )) contains function set_harmonic_occ ( node_r , node_z , mag , r , z , betain ) result ( normilized_wf ) use global_variables , only : PI , HBAR2_over_2m use spacial_function integer ( int32 ), intent ( in ) :: node_z , node_r , mag real ( real64 ), intent ( in ) :: r , z real ( real64 ), intent ( in ) :: betain real ( real64 ) :: alpha_z , alpha_r real ( real64 ) :: normilized_wf real ( real64 ) :: z_func real ( real64 ) :: rad_func real ( real64 ) :: rad_norm real ( real64 ) :: z_norm real ( real64 ) :: hbomz , hbomr hboma = 4 1.0d0 / dble ( num_n + num_p ) ** ( 1 d0 / 3 d0 ) hbomz = hboma * exp ( - xpi * betain ) hbomr = hboma * exp ( xpi / 2.0d0 * betain ) alpha_z = sqrt ( 2.0d0 * HBAR2_over_2m / hbomz ) alpha_r = sqrt ( 2.0d0 * HBAR2_over_2m / hbomr ) z_func = Hermite_n ( node_z , z / alpha_z ) * exp ( - z ** 2 / ( 2 d0 * alpha_z ** 2 )) rad_func = Laguerre_nl ( node_r , abs ( mag ),( r / alpha_r ) ** 2 ) * exp ( - r ** 2 / ( 2 d0 * alpha_r ** 2 )) * ( r / alpha_r ) ** abs ( mag ) z_norm = sqrt ( 1 d0 / alpha_z ) * sqrt ( 1 d0 / ( 2 d0 ** node_z * gamma ( dble ( node_z + 1 )))) * sqrt ( 1 d0 / sqrt ( PI )) rad_norm = sqrt ( 1 d0 / alpha_r ** 2 ) * sqrt ( gamma ( dble ( node_r + 1 )) / gamma ( dble ( node_r + abs ( mag ) + 1 ))) * sqrt ( 1 d0 / PI ) normilized_wf = z_norm * rad_norm * z_func * rad_func if ( normilized_wf > 1 ) then print * , node_r , node_z , abs ( mag ), r , z , betain print * , z_func , rad_func print * , z_norm , rad_norm print * , \"Error in harmonic_occ_wf: normilized_wf>1\" stop end if end function set_harmonic_occ function calc_occ_energy ( node_r , node_z , mag , betain ) result ( occ_energy ) integer ( int32 ), intent ( in ) :: node_z , node_r , mag real ( real64 ), intent ( in ) :: betain real ( real64 ) :: occ_energy real ( real64 ) :: hbomz , hbomr hbomz = hboma * exp ( - xpi * betain ) hbomr = hboma * exp ( xpi / 2.0d0 * betain ) occ_energy = hbomz * ( 0.5d0 + node_z ) + hbomr * dble (( 2 * node_r + abs ( mag ) + 1 )) end function calc_occ_energy end module harmonic_occ_wf","tags":"","loc":"sourcefile/harmonic_occ.f90.html"}]}